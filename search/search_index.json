{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83c\udf9b\ufe0f ESP32 Host MIDI","text":"<p>O hub MIDI universal para ESP32 \u2014 9 transportes, uma API.</p> <p>ESP32_Host_MIDI transforma o seu ESP32 em um hub MIDI multi-protocolo completo. Conecte um teclado USB, receba notas de um iPhone via Bluetooth, conecte o seu DAW pelo WiFi com RTP-MIDI, controle o Max/MSP via OSC, alcance sintetizadores vintage por um cabo DIN-5 e troque pacotes MIDI 2.0 com resolu\u00e7\u00e3o de 16 bits \u2014 tudo ao mesmo tempo, tudo pela mesma API limpa de eventos.</p>"},{"location":"#visao-geral-da-arquitetura","title":"Vis\u00e3o Geral da Arquitetura","text":"<pre><code>%%{init: {'theme': 'dark', 'themeVariables': {'primaryColor': '#1A237E', 'primaryTextColor': '#ffffff', 'primaryBorderColor': '#3949AB', 'lineColor': '#90CAF9', 'secondaryColor': '#3F51B5', 'tertiaryColor': '#006064', 'edgeLabelBackground': '#1A237E'}}}%%\nflowchart TD\n    classDef transport fill:#1A237E,color:#fff,stroke:#3949AB,font-weight:bold\n    classDef handler  fill:#283593,color:#fff,stroke:#5C6BC0,font-weight:bold\n    classDef output   fill:#004D40,color:#fff,stroke:#00897B,font-weight:bold\n\n    USB[\"\ud83d\udd0c USB Host\"]:::transport\n    BLE[\"\ud83d\udcf1 BLE MIDI\"]:::transport\n    DEV[\"\ud83d\udcbb USB Device\"]:::transport\n    UART[\"\ud83c\udfb9 UART / DIN-5\"]:::transport\n    RTP[\"\ud83c\udf10 RTP-MIDI\"]:::transport\n    ETH[\"\ud83d\udd17 Ethernet\"]:::transport\n    OSC[\"\ud83c\udfa8 OSC\"]:::transport\n    NOW[\"\ud83d\udce1 ESP-NOW\"]:::transport\n    M2[\"\ud83d\ude80 MIDI 2.0\"]:::transport\n\n    HANDLER[\"\u2699\ufe0f MIDIHandler\\nFila thread-safe \u00b7 Detec\u00e7\u00e3o de Acordes \u00b7 Notas Ativas\"]:::handler\n\n    GET[\"\ud83d\udce4 getQueue() \u00b7 getActiveNotes() \u00b7 lastChord()\"]:::output\n    SEND[\"\ud83d\udce8 sendNoteOn() \u00b7 sendCC() \u00b7 sendPitchBend()\"]:::output\n\n    USB  &amp; BLE  &amp; DEV  --&gt; HANDLER\n    UART &amp; RTP  &amp; ETH  --&gt; HANDLER\n    OSC  &amp; NOW  &amp; M2   --&gt; HANDLER\n\n    HANDLER --&gt; GET\n    HANDLER --&gt; SEND\n    SEND -.-&gt;|auto-forward| USB &amp; BLE &amp; UART &amp; RTP</code></pre>"},{"location":"#inicio-rapido","title":"In\u00edcio R\u00e1pido","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n// Arduino IDE: Tools &gt; USB Mode \u2192 \"USB Host\"\n\nvoid setup() {\n    Serial.begin(115200);\n    midiHandler.begin();  // inicializa USB Host + BLE automaticamente\n}\n\nvoid loop() {\n    midiHandler.task();  // processa todos os transportes\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"%-12s %-4s  ch=%d  vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.channel,\n            ev.velocity);\n    }\n}\n</code></pre>"},{"location":"#o-que-voce-pode-construir","title":"O Que Voc\u00ea Pode Construir","text":"\ud83c\udfb8 Instrumentos\ud83c\udf10 Pontes e Roteadores\ud83c\udfa8 Software Criativo\ud83d\udcca Educa\u00e7\u00e3o e Monitoramento <ul> <li>Pedalboard sem fio \u2014 bot\u00f5es \u2192 ESP-NOW \u2192 hub \u2192 DIN-5 para rack de efeitos</li> <li>Pad de bateria MIDI \u2014 sensores piezo + ADC \u2192 notas MIDI sens\u00edveis a velocidade</li> <li>Controlador MIDI customizado \u2014 encoders, faders \u2192 USB Device \u2192 qualquer DAW</li> <li>Theremin MIDI \u2014 sensores ultrass\u00f4nicos \u2192 pitch/volume \u2192 BLE para iPad</li> <li>Conversor MIDI para CV \u2014 ESP32 + MCP4728 DAC \u2192 0\u20135 V para Eurorack</li> </ul> <ul> <li>Interface USB sem fio \u2014 teclado USB \u2192 ESP32 \u2192 WiFi \u2192 macOS Logic Pro</li> <li>Adaptador DIN-5 para DAW \u2014 sintetizador vintage \u2192 ESP32 \u2192 USB Device</li> <li>Mesh de palco \u2014 ESP-NOW entre performers \u2192 sa\u00edda USB \u00fanica para FOH</li> <li>MIDI 2.0 \u2014 dois ESP32 trocam velocidade de 16 bits por UDP</li> </ul> <ul> <li>OSC \u2194 MIDI \u2014 Max/MSP, Pure Data, SuperCollider via WiFi UDP</li> <li>TouchOSC \u2192 sintetizador DIN-5 \u2014 touchscreen para hardware vintage</li> <li>Composi\u00e7\u00e3o algor\u00edtmica \u2014 Max \u2192 OSC \u2192 ESP32 \u2192 BLE \u2192 app no iPad</li> </ul> <ul> <li>Piano roll ao vivo \u2014 25 teclas com rolagem em display 1.9\"</li> <li>Detector de acordes \u2014 toque um acorde, veja \"Cmaj7\" instantaneamente</li> <li>Logger de eventos \u2014 timestamps, canal, velocidade, agrupamento de acordes</li> </ul>"},{"location":"#galeria","title":"Galeria","text":"Piano roll de 25 teclas Detec\u00e7\u00e3o de acordes (Gingoduino) MIDI 2.0 UDP \u2014 velocidade 16-bit RTP-MIDI no macOS Audio MIDI Setup BLE MIDI Receiver (iPhone \u2192 ESP32) Fila de eventos em tempo real"},{"location":"#navegacao","title":"Navega\u00e7\u00e3o","text":"<ul> <li> <p> Guia</p> <p>Do b\u00e1sico ao avan\u00e7ado: instala\u00e7\u00e3o, primeiros passos, configura\u00e7\u00e3o.</p> <p> Come\u00e7ar</p> </li> <li> <p> Transportes</p> <p>9 protocolos documentados: USB, BLE, WiFi, Ethernet, DIN-5, ESP-NOW, OSC, MIDI 2.0.</p> <p> Ver Transportes</p> </li> <li> <p> Funcionalidades</p> <p>Detec\u00e7\u00e3o de acordes, notas ativas, hist\u00f3rico PSRAM e integra\u00e7\u00e3o com Gingoduino.</p> <p> Ver Funcionalidades</p> </li> <li> <p> API</p> <p>Refer\u00eancia completa de classes, m\u00e9todos e estruturas de dados.</p> <p> Ver API</p> </li> <li> <p> Exemplos</p> <p>Sketches prontos para usar: piano roll, OSC bridge, ESP-NOW Jam, MIDI 2.0 e mais.</p> <p> Ver Exemplos</p> </li> <li> <p> Avan\u00e7ado</p> <p>Compatibilidade de hardware, MIDI 2.0 / UMP e troubleshooting.</p> <p> Ver Avan\u00e7ado</p> </li> </ul>"},{"location":"#matriz-de-transportes","title":"Matriz de Transportes","text":"Transporte Protocolo F\u00edsica Lat\u00eancia Chips \ud83d\udd0c USB Host USB MIDI 1.0 Cabo USB-OTG &lt; 1 ms S3 / S2 / P4 \ud83d\udcf1 BLE MIDI BLE MIDI 1.0 Bluetooth LE 3\u201315 ms Qualquer ESP32 com BT \ud83d\udcbb USB Device USB MIDI 1.0 Cabo USB-OTG &lt; 1 ms S3 / S2 / P4 \ud83d\udce1 ESP-NOW ESP-NOW R\u00e1dio 2,4 GHz 1\u20135 ms Qualquer ESP32 \ud83c\udf10 RTP-MIDI AppleMIDI / RFC 6295 WiFi UDP 5\u201320 ms Qualquer ESP32 com WiFi \ud83d\udd17 Ethernet AppleMIDI / RFC 6295 Cabeado 2\u201310 ms W5500 SPI ou ESP32-P4 \ud83c\udfa8 OSC Open Sound Control WiFi UDP 5\u201315 ms Qualquer ESP32 com WiFi \ud83c\udfb9 UART / DIN-5 Serial MIDI 1.0 DIN-5 &lt; 1 ms Qualquer ESP32 \ud83d\ude80 MIDI 2.0 / UMP UMP sobre UDP WiFi UDP 5\u201320 ms Qualquer ESP32 com WiFi"},{"location":"#links-do-ecossistema","title":"Links do Ecossistema","text":"<ul> <li>Gingoduino \u2014 biblioteca de teoria musical para ESP32 (detecta acordes, escalas e progress\u00f5es)</li> <li>Gingo \u2014 vers\u00e3o Python do Gingoduino para desktop e scripts</li> <li>LilyGO T-Display-S3 \u2014 placa recomendada (ESP32-S3 + display 1.9\")</li> </ul>"},{"location":"MIDI2_Research/","title":"MIDI 1.0 vs MIDI 2.0 \u2014 Pesquisa T\u00e9cnica","text":"<p>Gerado em 2026-02-19 como refer\u00eancia para futura compatibilidade MIDI 2.0 neste projeto.</p>"},{"location":"MIDI2_Research/#1-mudancas-no-protocolo-de-mensagens","title":"1. Mudan\u00e7as no Protocolo de Mensagens","text":""},{"location":"MIDI2_Research/#midi-10-formato-atual","title":"MIDI 1.0 \u2014 Formato atual","text":"<p>MIDI 1.0 usa um byte stream ass\u00edncrono a 31.25 kbaud. Mensagens de comprimento vari\u00e1vel:</p> <ul> <li>Status byte: 1 byte (MSB=1, nibble alto = tipo, nibble baixo = canal)</li> <li>Data bytes: 1 ou 2 bytes (MSB=0, valor 0\u2013127, ou seja, 7 bits de resolu\u00e7\u00e3o)</li> </ul> <pre><code>Note On:        [9n kk vv]   (3 bytes: status, note, velocity)\nNote Off:       [8n kk vv]\nControl Change: [Bn cc vv]\nPitch Bend:     [En ll hh]   (14 bits, 0\u201316383)\nProg. Change:   [Cn pp]      (2 bytes)\n</code></pre>"},{"location":"MIDI2_Research/#midi-20-universal-midi-packet-ump","title":"MIDI 2.0 \u2014 Universal MIDI Packet (UMP)","text":"<p>MIDI 2.0 abandona o byte stream e introduz pacotes alinhados a 32 bits. Cada mensagem ocupa 1, 2, 3 ou 4 palavras de 32 bits.</p> <p>Resolu\u00e7\u00e3o comparada:</p> Par\u00e2metro MIDI 1.0 MIDI 2.0 Velocity 7 bits (128 valores) 16 bits (65.536 valores) Control Change 7 bits (128 valores) 32 bits (4.294.967.296 valores) Pitch Bend 14 bits (16.384) 32 bits Per-Note Pitch N\u00e3o existe 32 bits por nota Canais totais 16 256 (16 grupos \u00d7 16 canais)"},{"location":"MIDI2_Research/#2-universal-midi-packet-ump-estrutura","title":"2. Universal MIDI Packet (UMP) \u2014 Estrutura","text":""},{"location":"MIDI2_Research/#cabecalho-dos-primeiros-4-bits","title":"Cabe\u00e7alho dos primeiros 4 bits","text":"<pre><code>Bits [31:28] = Message Type (MT)\nBits [27:24] = Group (0-15)\nBits [23:xx] = conte\u00fado espec\u00edfico\n</code></pre>"},{"location":"MIDI2_Research/#tabela-de-message-types","title":"Tabela de Message Types","text":"MT Tipo Tamanho 0x0 Utility (JR Timestamp, etc.) 32 bits 0x1 System Common &amp; Real Time 32 bits 0x2 MIDI 1.0 Channel Voice (em UMP) 32 bits 0x3 SysEx 7-bit segmentado 64 bits 0x4 MIDI 2.0 Channel Voice 64 bits 0x5 SysEx 8-bit / Mixed Data Set 128 bits 0xD Flex Data 128 bits 0xF UMP Stream (Endpoint Discovery) 128 bits"},{"location":"MIDI2_Research/#mensagens-midi-20-channel-voice-mt0x4-64-bits","title":"Mensagens MIDI 2.0 Channel Voice (MT=0x4) \u2014 64 bits","text":"<p>Note On/Off: <pre><code>Word 0: [MT=4][Group 4b][Opcode 4b][Canal 4b][Note 8b][Attribute Type 8b]\nWord 1: [Velocity 16b][Attribute Value 16b]\n</code></pre> - Velocity Note Off 0x0000 = sil\u00eancio absoluto (diferente de Note On vel=0 do MIDI 1.0) - Attribute Type 0x03 = Pitch 7.9 (microafina\u00e7\u00e3o com resolu\u00e7\u00e3o de 1/512 semitom)</p> <p>Control Change: <pre><code>Word 0: [MT=4][Group][0xB][Canal][Index CC 8b][00000000]\nWord 1: [Valor CC 32b]\n</code></pre></p> <p>Pitch Bend: <pre><code>Word 0: [MT=4][Group][0x6][Canal][00000000][00000000]\nWord 1: [Valor 32b]   \u2190 0x80000000 = centro\n</code></pre></p> <p>Per-Note Pitch Bend (novo): <pre><code>Word 0: [MT=4][Group][0x6 per-note][Canal][Note 8b][00000000]\nWord 1: [Valor 32b]\n</code></pre> Permite pitch bend independente por nota \u2014 torna MPE desnecess\u00e1rio na maioria dos casos.</p> <p>RPN/NRPN nativos (novo): <pre><code>Word 0: [MT=4][Group][0x2=RPN ou 0x3=NRPN][Canal][Bank 8b][Index 8b]\nWord 1: [Valor 32b]\n</code></pre> Antes precisava de 4\u20136 CCs para o mesmo efeito.</p>"},{"location":"MIDI2_Research/#3-midi-capability-inquiry-midi-ci","title":"3. MIDI Capability Inquiry (MIDI-CI)","text":"<p>Mecanismo de negocia\u00e7\u00e3o de capacidades via Universal SysEx (F0 7E ... F7) antes de ativar recursos MIDI 2.0.</p>"},{"location":"MIDI2_Research/#processo-de-discovery","title":"Processo de Discovery","text":"<pre><code>Iniciador \u2192 (SysEx Broadcast Discovery, MUID broadcast 0x0FFFFFFF)\n          \u2190 (Reply to Discovery + MUID pr\u00f3prio do dispositivo)\n</code></pre>"},{"location":"MIDI2_Research/#negociacao-de-protocolo","title":"Negocia\u00e7\u00e3o de Protocolo","text":"<pre><code>Iniciador \u2192 (Initiate Protocol Negotiation, lista de protocolos aceitos)\n          \u2190 (Reply: protocolo confirmado)\nIniciador \u2192 (Set New Protocol)\n          \u2192 (Test New Protocol: mensagem de eco)\n          \u2190 (Test New Protocol Response)\nIniciador \u2192 (Confirmation New Protocol Established)\n</code></pre> <p>Nota: Protocol Negotiation via MIDI-CI foi marcado como deprecated na UMP v1.1. A abordagem moderna usa UMP Stream Messages (MT=0xF) diretamente no transporte USB MIDI 2.0.</p>"},{"location":"MIDI2_Research/#tres-areas-funcionais-do-midi-ci","title":"Tr\u00eas \u00e1reas funcionais do MIDI-CI","text":"<ol> <li>Protocol Negotiation \u2014 deprecated em favor do UMP Endpoint Discovery</li> <li>Profile Configuration \u2014 conjuntos predefinidos de mapeamentos por categoria de instrumento (Piano, Drawbar Organ, Percussion, Mixing, Lighting\u2026)</li> <li>Property Exchange \u2014 troca de metadados JSON via SysEx (lista de patches, nomes de controladores, info do fabricante, etc.)</li> </ol>"},{"location":"MIDI2_Research/#4-retrocompatibilidade-midi-10-midi-20","title":"4. Retrocompatibilidade MIDI 1.0 \u2194 MIDI 2.0","text":""},{"location":"MIDI2_Research/#regras-de-conversao-bit-replication","title":"Regras de convers\u00e3o (bit-replication)","text":"<p>MIDI 1.0 \u2192 MIDI 2.0 (upscaling): <pre><code>// Velocity 7-bit \u2192 16-bit\nuint16_t v16 = (v7 &lt;&lt; 9) | (v7 &lt;&lt; 2) | (v7 &gt;&gt; 5);\n\n// CC 7-bit \u2192 32-bit (mesma t\u00e9cnica)\nuint32_t cc32 = (cc7 &lt;&lt; 25) | (cc7 &lt;&lt; 18) | (cc7 &lt;&lt; 11) | (cc7 &lt;&lt; 4) | (cc7 &gt;&gt; 3);\n\n// Pitch Bend 14-bit \u2192 32-bit\nuint32_t pb32 = (pb14 &lt;&lt; 18) | (pb14 &lt;&lt; 4) | (pb14 &gt;&gt; 10);\n</code></pre></p> <p>MIDI 2.0 \u2192 MIDI 1.0 (downscaling): <pre><code>uint8_t  v7   = v16  &gt;&gt; 9;\nuint8_t  cc7  = cc32 &gt;&gt; 25;\nuint16_t pb14 = pb32 &gt;&gt; 18;\n</code></pre></p>"},{"location":"MIDI2_Research/#5-usb-midi-20","title":"5. USB MIDI 2.0","text":""},{"location":"MIDI2_Research/#dual-alternate-setting","title":"Dual Alternate Setting","text":"<p>Um dispositivo USB MIDI 2.0 exp\u00f5e dois Alternate Settings no mesmo Interface:</p> <ul> <li>altset 0: Descritores USB MIDI 1.0 cl\u00e1ssicos (compat\u00edvel com qualquer host)</li> <li>altset 1: Descritores USB MIDI 2.0 com Group Terminal Blocks (GTBs), transporta UMP puro</li> </ul> <p>O host seleciona automaticamente o altset mais avan\u00e7ado que suporta.</p> <p>Suporte a altset 1: - Linux \u2265 6.5 - macOS \u2265 14 (Sonoma) - Android \u2265 13 - Windows 11 (com Windows MIDI Services)</p>"},{"location":"MIDI2_Research/#group-terminal-blocks-gtbs","title":"Group Terminal Blocks (GTBs)","text":"<pre><code>bGrpTrmBlkID      // ID \u00fanico (1\u2013255)\nbGrpTrmBlkType    // 0x00 = bidirecional\nnGroupTrm         // Primeiro grupo UMP (0 = Group 1)\nnNumGroupTrm      // Quantos grupos abrange\nbMIDIProtocol     // 0x01 = MIDI 1.0, 0x02 = MIDI 2.0\n</code></pre>"},{"location":"MIDI2_Research/#ump-endpoint-discovery-mt0xf-sobre-usb-midi-20","title":"UMP Endpoint Discovery (MT=0xF) sobre USB MIDI 2.0","text":"<pre><code>Host \u2192 UMP Endpoint Discovery       (MT=0xF, Opcode=0x000)\n     \u2190 UMP Endpoint Info Notif.     (MT=0xF, Opcode=0x001)\n     \u2190 UMP Endpoint Name Notif.     (MT=0xF, Opcode=0x003)\nHost \u2192 UMP Function Block Discovery (MT=0xF, Opcode=0x010)\n     \u2190 UMP Function Block Info      (MT=0xF, Opcode=0x011)\n</code></pre>"},{"location":"MIDI2_Research/#6-ble-midi-20","title":"6. BLE MIDI 2.0","text":"<p>Ainda n\u00e3o existe especifica\u00e7\u00e3o oficial de BLE MIDI 2.0 (fevereiro de 2026).</p> <p>A spec BLE MIDI original (Apple/MMA, 2015) transporta apenas MIDI 1.0. O que \u00e9 poss\u00edvel hoje: - Usar o transporte BLE MIDI 1.0 para carregar SysEx de MIDI-CI (Profile Configuration, Property Exchange) - UMP nativo sobre BLE: aguardando spec oficial da MIDI Association</p>"},{"location":"MIDI2_Research/#formato-do-pacote-ble-midi-10-referencia","title":"Formato do pacote BLE MIDI 1.0 (refer\u00eancia)","text":"<pre><code>Byte 0 (Header):    [1][t6..t0]   MSB=1, bits 6-0 = upper timestamp\nByte 1 (Timestamp): [1][t6..t0]   MSB=1, bits 6-0 = lower timestamp\nBytes N+: MIDI status + data bytes normais\nTimestamp: 13 bits, unidade = ms, max = 8192 ms\n</code></pre>"},{"location":"MIDI2_Research/#7-o-que-precisariamos-fazer-neste-projeto","title":"7. O que precisar\u00edamos fazer neste projeto","text":""},{"location":"MIDI2_Research/#midieventdata-extensao-para-midi-20","title":"<code>MIDIEventData</code> \u2014 extens\u00e3o para MIDI 2.0","text":"<pre><code>// Campos atuais (MIDI 1.0)\nint velocity;     // 0\u2013127 (7 bits)\nint pitchBend;    // 0\u201316383 (14 bits)\n\n// Campos adicionais para MIDI 2.0\nuint16_t velocity16;      // 0\u201365535\nuint32_t controlValue32;  // 0\u20134.294.967.295\nuint32_t pitchBend32;     // centro = 0x80000000\nuint8_t  attributeType;   // Per-note attribute type\nuint16_t attributeValue;  // Per-note attribute value\nuint8_t  umpGroup;        // Grupo UMP (0\u201315)\nbool     isMidi2;         // flag MIDI 1.0 vs 2.0\n</code></pre>"},{"location":"MIDI2_Research/#usbconnection-suporte-a-altset-1","title":"<code>USBConnection</code> \u2014 suporte a altset 1","text":"<ul> <li>Detectar se o dispositivo conectado exp\u00f5e altset 1</li> <li>Se sim: processar pacotes UMP (32/64 bits) em vez de byte stream</li> <li>Se n\u00e3o: continuar com o processamento MIDI 1.0 atual</li> </ul>"},{"location":"MIDI2_Research/#midihandler-parser-ump","title":"<code>MIDIHandler</code> \u2014 parser UMP","text":"<pre><code>// Novo m\u00e9todo para processar pacotes UMP\nvoid handleUMPPacket(const uint32_t* words, size_t wordCount);\n</code></pre>"},{"location":"MIDI2_Research/#bleconnection-sem-mudancas-por-enquanto","title":"<code>BLEConnection</code> \u2014 sem mudan\u00e7as por enquanto","text":"<p>Aguardar especifica\u00e7\u00e3o oficial de BLE MIDI 2.0. MIDI-CI pode ser adicionado via SysEx sobre o transporte BLE atual.</p>"},{"location":"MIDI2_Research/#conversao-automatica","title":"Convers\u00e3o autom\u00e1tica","text":"<p>Implementar as fun\u00e7\u00f5es de upscaling/downscaling da spec para manter compatibilidade transparente com dispositivos MIDI 1.0.</p>"},{"location":"MIDI2_Research/#8-bibliotecas-de-referencia","title":"8. Bibliotecas de Refer\u00eancia","text":"Projeto Descri\u00e7\u00e3o AM_MIDI2.0Lib Biblioteca C++ oficial para embedded MIDI 2.0. ~10KB compilado, ~1KB RAM, processa pacote a pacote tusb_ump Driver USB MIDI 2.0 sobre TinyUSB (relevante pois o ESP32-S3 usa TinyUSB)"},{"location":"MIDI2_Research/#9-fontes","title":"9. Fontes","text":"<ul> <li>MIDI.org \u2014 MIDI 2.0 Overview</li> <li>MIDI.org \u2014 UMP Specification</li> <li>USB.org \u2014 USB MIDI Class Definition v2.0</li> <li>Linux Kernel \u2014 MIDI 2.0 on Linux</li> <li>Microsoft \u2014 Windows MIDI Services MIDI 2.0</li> <li>midi2-dev/AM_MIDI2.0Lib (GitHub)</li> <li>midi2-dev/tusb_ump (GitHub)</li> <li>Sound On Sound \u2014 Introducing MIDI 2.0</li> <li>Wikipedia \u2014 MIDI 2.0</li> </ul>"},{"location":"roadmap/","title":"\ud83d\uddfa\ufe0f Roadmap","text":"<p>Estado atual e dire\u00e7\u00e3o futura da biblioteca ESP32_Host_MIDI.</p>"},{"location":"roadmap/#estado-atual-v500","title":"Estado Atual \u2014 v5.0.0","text":"<p>A vers\u00e3o 5.0.0 \u00e9 uma biblioteca madura e est\u00e1vel. O n\u00facleo \u2014 9 transportes, uma API \u2014 est\u00e1 completo e funcional.</p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef done fill:#1B5E20,color:#fff,stroke:#2E7D32,font-weight:bold\n    classDef feat fill:#1A237E,color:#fff,stroke:#283593,font-weight:bold\n\n    subgraph T[\"\ud83d\udce1 Transportes\"]\n        direction LR\n        USB[\"\ud83d\udd0c USB Host\"]:::done\n        BLE[\"\ud83d\udcf1 BLE MIDI\"]:::done\n        USBDEV[\"\ud83d\udcbb USB Device\"]:::done\n        ESPNOW[\"\ud83d\udce1 ESP-NOW\"]:::done\n        RTP[\"\ud83c\udf10 RTP-MIDI\"]:::done\n        ETH[\"\ud83d\udd17 Ethernet\"]:::done\n        OSC[\"\ud83c\udfa8 OSC\"]:::done\n        UART[\"\ud83c\udfb9 UART/DIN-5\"]:::done\n        MIDI2[\"\ud83d\ude80 MIDI 2.0\"]:::done\n    end\n\n    subgraph F[\"\u2699\ufe0f Funcionalidades\"]\n        direction LR\n        CHORD[\"Chord Detection\"]:::done\n        ACTIVE[\"Active Notes\"]:::done\n        HIST[\"PSRAM History\"]:::done\n        GINGO[\"Gingo Adapter\"]:::done\n    end</code></pre>"},{"location":"roadmap/#em-desenvolvimento","title":"Em Desenvolvimento","text":""},{"location":"roadmap/#midi-ci-capability-inquiry","title":"\ud83d\udd04 MIDI-CI (Capability Inquiry)","text":"<p>O que \u00e9: Mecanismo de negocia\u00e7\u00e3o do MIDI 2.0 \u2014 dispositivos se descobrem mutuamente e negociam o conjunto de funcionalidades suportadas.</p> <p>Por que importa: Necess\u00e1rio para comunica\u00e7\u00e3o MIDI 2.0 \"oficial\" entre dispositivos certificados.</p> <p>Status: Pesquisa e design.</p>"},{"location":"roadmap/#profile-negotiation","title":"\ud83d\udd04 Profile Negotiation","text":"<p>O que \u00e9: Perfis MIDI 2.0 definem comportamentos padronizados (ex: \"Piano Profile\", \"Drawbar Organ Profile\").</p> <p>Por que importa: Permite que dispositivos MIDI 2.0 interoperem sem configura\u00e7\u00e3o manual.</p> <p>Status: Aguarda MIDI-CI.</p>"},{"location":"roadmap/#property-exchange","title":"\ud83d\udd04 Property Exchange","text":"<p>O que \u00e9: Metadados em JSON trocados entre dispositivos MIDI 2.0 (nome, fabricante, vers\u00e3o, capabilities).</p> <p>Por que importa: Permite que DAWs reconhe\u00e7am e configurem dispositivos MIDI 2.0 automaticamente.</p> <p>Status: Futuro.</p>"},{"location":"roadmap/#considerado-para-o-futuro","title":"Considerado para o Futuro","text":"Feature Prioridade Notas USB MIDI 2.0 Host Alta Quando TinyUSB suportar MIDI 2.0 Multi-device USB Hub M\u00e9dia ESP32-P4 HS j\u00e1 suporta \u2014 integra\u00e7\u00e3o pendente SysEx handler M\u00e9dia Atualmente ignorado Running Status TX Baixa Otimiza\u00e7\u00e3o de largura de banda DIN-5 BLE MIDI Central (Scanner) Alta Conectar ao inv\u00e9s de ser conectado MIDI Clock generator M\u00e9dia BPM preciso via timer FreeRTOS Virtual MIDI ports Baixa M\u00faltiplas portas no USB Device"},{"location":"roadmap/#contribuir","title":"Contribuir","text":"<p>Contribui\u00e7\u00f5es s\u00e3o bem-vindas!</p> <ul> <li>Issues: github.com/sauloverissimo/ESP32_Host_MIDI/issues</li> <li>Pull Requests: fork + branch + PR</li> <li>Discuss\u00f5es: use as Issues para propor features</li> </ul>"},{"location":"roadmap/#adicionar-um-novo-transporte","title":"Adicionar um Novo Transporte","text":"<p>A arquitetura \u00e9 extens\u00edvel \u2014 qualquer protocolo pode virar um transporte:</p> <pre><code>class MeuTransporte : public MIDITransport {\npublic:\n    void begin() { /* inicializar */ }\n\n    void task() override {\n        if (temDados()) {\n            uint8_t dados[3];\n            lerDados(dados);\n            dispatchMidiData(dados, 3);  // injeta no MIDIHandler\n        }\n    }\n\n    bool isConnected() const override { return true; }\n\n    bool sendMidiMessage(const uint8_t* data, size_t len) override {\n        return enviarDados(data, len);\n    }\n};\n</code></pre>"},{"location":"roadmap/#changelog","title":"Changelog","text":""},{"location":"roadmap/#v500","title":"v5.0.0","text":"<ul> <li>9 transportes simult\u00e2neos (USB, BLE, USB Device, ESP-NOW, RTP-MIDI, Ethernet, OSC, UART, MIDI 2.0 UDP)</li> <li>Camada de abstra\u00e7\u00e3o <code>MIDITransport</code> (interface unificada)</li> <li><code>addTransport()</code> para transportes externos</li> <li>MIDI 2.0 / UMP: builder, parser, scaler (16/32-bit)</li> <li><code>MIDI2UDPConnection</code> \u2014 protocolo customizado ESP32\u2194ESP32</li> <li><code>USBDeviceConnection</code> \u2014 USB MIDI class-compliant (TinyUSB)</li> <li><code>OSCConnection</code> \u2014 bridge bidirecional OSC \u2194 MIDI</li> <li><code>EthernetMIDIConnection</code> \u2014 AppleMIDI sobre W5500 SPI</li> <li><code>RTPMIDIConnection</code> \u2014 AppleMIDI sobre WiFi com mDNS</li> <li><code>UARTConnection</code> \u2014 DIN-5 MIDI serial (31250 baud)</li> <li><code>ESPNowConnection</code> \u2014 mesh P2P sem router</li> <li><code>GingoAdapter</code> \u2014 integra\u00e7\u00e3o com Gingoduino</li> <li>PSRAM history buffer (circular, fallback para heap)</li> <li>Ring buffers thread-safe com <code>portMUX</code></li> <li>Feature detection autom\u00e1tico por chip (macros)</li> </ul>"},{"location":"roadmap/#v4x","title":"v4.x","text":"<ul> <li>USB Host + BLE MIDI b\u00e1sico</li> <li>Fila de eventos com chordIndex</li> <li>Detec\u00e7\u00e3o de acordes por janela de tempo</li> <li>Notas ativas (fillActiveNotes, getActiveNotesVector)</li> </ul>"},{"location":"roadmap/#v3x-e-anteriores","title":"v3.x e anteriores","text":"<ul> <li>Implementa\u00e7\u00e3o inicial USB Host</li> <li>BLE MIDI perif\u00e9rico</li> </ul>"},{"location":"roadmap/#licenca","title":"Licen\u00e7a","text":"<p>MIT \u2014 use, modifique, distribua livremente, com ou sem fins comerciais.</p> <p>Veja LICENSE para o texto completo.</p> <p> Constru\u00eddo com \u2764\ufe0f para m\u00fasicos, makers e pesquisadores. github.com/sauloverissimo/ESP32_Host_MIDI </p>"},{"location":"api/referencia/","title":"\ud83d\udcda Refer\u00eancia da API","text":"<p>Refer\u00eancia completa de todas as classes, estruturas e m\u00e9todos da biblioteca ESP32_Host_MIDI.</p>"},{"location":"api/referencia/#midieventdata","title":"MIDIEventData","text":"<p>Estrutura que representa um evento MIDI parseado. Retornada por <code>getQueue()</code>.</p> <pre><code>struct MIDIEventData {\n    int index;                // Contador global (\u00fanico, crescente)\n    int msgIndex;             // Liga pares NoteOn \u2194 NoteOff\n    unsigned long timestamp;  // millis() no momento do evento\n    unsigned long delay;      // \u0394t em ms desde o evento anterior\n\n    int channel;              // Canal MIDI: 1\u201316\n    std::string status;       // Tipo: \"NoteOn\" | \"NoteOff\" | \"ControlChange\" |\n                              //       \"ProgramChange\" | \"PitchBend\" | \"ChannelPressure\"\n    int note;                 // N\u00famero MIDI (0\u2013127) ou n\u00famero do controlador (CC)\n    std::string noteName;     // \"C\", \"C#\", \"D\" ... (vazio para n\u00e3o-notas)\n    std::string noteOctave;   // \"C4\", \"D#5\", \"G3\" ... (vazio para n\u00e3o-notas)\n    int velocity;             // Velocidade (0\u2013127); tamb\u00e9m valor de CC, program, pressure\n    int chordIndex;           // \u00cdndice de agrupamento de acorde (simult\u00e2neas = mesmo \u00edndice)\n    int pitchBend;            // Valor raw 14-bit: 0\u201316383 (centro = 8192). 0 para outros tipos.\n};\n</code></pre>"},{"location":"api/referencia/#mapeamento-por-tipo-de-mensagem","title":"Mapeamento por tipo de mensagem","text":"<code>status</code> <code>note</code> <code>velocity</code> <code>pitchBend</code> <code>\"NoteOn\"</code> Nota MIDI (0\u2013127) Velocidade (0\u2013127) 0 <code>\"NoteOff\"</code> Nota MIDI (0\u2013127) Release velocity 0 <code>\"ControlChange\"</code> CC number (0\u2013127) CC value (0\u2013127) 0 <code>\"ProgramChange\"</code> Program (0\u2013127) Program (0\u2013127) 0 <code>\"PitchBend\"</code> 0 0 0\u201316383 (centro=8192) <code>\"ChannelPressure\"</code> 0 Pressure (0\u2013127) 0"},{"location":"api/referencia/#midihandlerconfig","title":"MIDIHandlerConfig","text":"<p>Struct de configura\u00e7\u00e3o passada para <code>midiHandler.begin(cfg)</code>.</p> <pre><code>struct MIDIHandlerConfig {\n    int maxEvents = 20;\n    // Capacidade m\u00e1xima da fila de eventos. Eventos mais antigos s\u00e3o descartados\n    // quando a fila atinge este limite.\n\n    unsigned long chordTimeWindow = 0;\n    // Janela de tempo (ms) para agrupar notas simult\u00e2neas no mesmo chordIndex.\n    // 0 = novo acorde apenas quando TODAS as notas s\u00e3o soltas.\n    // 30\u201380 ms = ideal para teclados f\u00edsicos.\n\n    int velocityThreshold = 0;\n    // Filtra NoteOn com velocity &lt; velocityThreshold. 0 = desabilitado.\n\n    int historyCapacity = 0;\n    // Capacidade do buffer hist\u00f3rico circular (em PSRAM se dispon\u00edvel).\n    // 0 = desabilitado.\n\n    const char* bleName = \"ESP32 MIDI BLE\";\n    // Nome anunciado pelo perif\u00e9rico BLE MIDI.\n};\n</code></pre>"},{"location":"api/referencia/#midihandler","title":"MIDIHandler","text":"<p>Singleton global: <code>extern MIDIHandler midiHandler;</code></p>"},{"location":"api/referencia/#setup","title":"Setup","text":"<pre><code>void begin();\n// Inicializa com configura\u00e7\u00e3o padr\u00e3o.\n// Registra automaticamente: USBConnection (se S2/S3/P4), BLEConnection (se BT habilitado)\n\nvoid begin(const MIDIHandlerConfig&amp; config);\n// Inicializa com configura\u00e7\u00e3o personalizada.\n\nvoid addTransport(MIDITransport* transport);\n// Registra um transporte externo (at\u00e9 4 transportes externos adicionais).\n// Deve ser chamado ANTES de begin().\n\nvoid setQueueLimit(int maxEvents);\n// Altera a capacidade da fila ap\u00f3s begin().\n\nvoid enableHistory(int capacity);\n// Ativa buffer hist\u00f3rico circular (usa PSRAM se dispon\u00edvel, fallback para heap).\n// Pode ser chamado ap\u00f3s begin().\n</code></pre>"},{"location":"api/referencia/#loop","title":"Loop","text":"<pre><code>void task();\n// Chame em todo loop(). Drena os ring buffers de todos os transportes,\n// parseia mensagens, atualiza fila, notas ativas e acordes.\n</code></pre>"},{"location":"api/referencia/#recepcao-fila-de-eventos","title":"Recep\u00e7\u00e3o \u2014 Fila de Eventos","text":"<pre><code>const std::deque&lt;MIDIEventData&gt;&amp; getQueue() const;\n// Retorna a fila de eventos desde a \u00faltima chamada de task().\n// Itere com range-for: for (const auto&amp; ev : midiHandler.getQueue()) {}\n\nvoid clearQueue();\n// Esvazia a fila imediatamente.\n</code></pre>"},{"location":"api/referencia/#recepcao-notas-ativas","title":"Recep\u00e7\u00e3o \u2014 Notas Ativas","text":"<pre><code>std::string getActiveNotes() const;\n// Retorna string formatada: \"{C4, E4, G4}\"\n\nstd::string getActiveNotesString() const;\n// Alias de getActiveNotes()\n\nstd::vector&lt;std::string&gt; getActiveNotesVector() const;\n// Retorna vetor de strings: [\"C4\", \"E4\", \"G4\"]\n\nsize_t getActiveNotesCount() const;\n// N\u00famero de notas atualmente pressionadas.\n\nvoid fillActiveNotes(bool out[128]) const;\n// Preenche array[128] \u2014 out[note] = true se a nota estiver ativa.\n\nvoid clearActiveNotesNow();\n// Zera o mapa de notas ativas (\u00fatil ap\u00f3s reconex\u00e3o ou reset).\n</code></pre>"},{"location":"api/referencia/#recepcao-acordes","title":"Recep\u00e7\u00e3o \u2014 Acordes","text":"<pre><code>int lastChord(const std::deque&lt;MIDIEventData&gt;&amp; queue) const;\n// Retorna o chordIndex mais recente na fila. -1 se vazia.\n\nstd::vector&lt;std::string&gt; getChord(\n    int chord,\n    const std::deque&lt;MIDIEventData&gt;&amp; queue,\n    const std::vector&lt;std::string&gt;&amp; fields = {\"all\"},\n    bool includeLabels = false\n) const;\n// Retorna valores de campo(s) para todas as notas com chordIndex == chord.\n// fields: {\"noteOctave\"} | {\"noteName\"} | {\"velocity\"} | {\"all\"} | combina\u00e7\u00f5es\n// includeLabels: prefixar cada valor com \"campo:valor\"\n\nstd::vector&lt;std::string&gt; getAnswer(\n    const std::string&amp; field = \"all\",\n    bool includeLabels = false\n) const;\n// Atalho para lastChord + getChord com um \u00fanico campo.\n\nstd::vector&lt;std::string&gt; getAnswer(\n    const std::vector&lt;std::string&gt;&amp; fields,\n    bool includeLabels = false\n) const;\n// Atalho para lastChord + getChord com m\u00faltiplos campos.\n</code></pre>"},{"location":"api/referencia/#envio-de-midi","title":"Envio de MIDI","text":"<p>Todos os m\u00e9todos de envio transmitem para todos os transportes que suportam envio:</p> <pre><code>bool sendNoteOn(uint8_t channel, uint8_t note, uint8_t velocity);\n// channel: 1\u201316 | note: 0\u2013127 | velocity: 0\u2013127\n// Retorna true se pelo menos um transporte enviou.\n\nbool sendNoteOff(uint8_t channel, uint8_t note, uint8_t velocity);\n// velocity tipicamente 0 para NoteOff.\n\nbool sendControlChange(uint8_t channel, uint8_t controller, uint8_t value);\n// controller: 0\u2013127 (CC#7=volume, CC#11=expression, CC#64=sustain, etc.)\n// value: 0\u2013127\n\nbool sendProgramChange(uint8_t channel, uint8_t program);\n// program: 0\u2013127\n\nbool sendPitchBend(uint8_t channel, int value);\n// value: -8192 a +8191 (convertido internamente para 0\u201316383)\n\nbool sendRaw(const uint8_t* data, size_t length);\n// Envia bytes MIDI crus para todos os transportes.\n\nbool sendBleRaw(const uint8_t* data, size_t length);\n// Alias de sendRaw() (compatibilidade retroativa).\n</code></pre>"},{"location":"api/referencia/#ble-status","title":"BLE Status","text":"<pre><code>#if ESP32_HOST_MIDI_HAS_BLE\nbool isBleConnected() const;\n// Retorna true se um dispositivo BLE MIDI estiver conectado.\n#endif\n</code></pre>"},{"location":"api/referencia/#debug-callback","title":"Debug Callback","text":"<pre><code>typedef void (*RawMidiCallback)(const uint8_t* raw, size_t rawLen,\n                                 const uint8_t* midi3);\nvoid setRawMidiCallback(RawMidiCallback cb);\n// cb \u00e9 chamado com os bytes MIDI crus ANTES do parsing.\n// raw = payload USB-MIDI completo; midi3 = os 3 bytes MIDI.\n// Use nullptr para desabilitar.\n</code></pre>"},{"location":"api/referencia/#miditransport","title":"MIDITransport","text":"<p>Interface abstrata implementada por todos os transportes.</p> <pre><code>class MIDITransport {\npublic:\n    virtual ~MIDITransport() = default;\n\n    // Obrigat\u00f3rio \u2014 implementar nas subclasses:\n    virtual void task() = 0;                // Chamado a cada loop() pelo MIDIHandler\n    virtual bool isConnected() const = 0;   // Status atual da conex\u00e3o\n\n    // Opcional \u2014 implementar nas subclasses:\n    virtual bool sendMidiMessage(const uint8_t* data, size_t length);\n    // Retorna true se enviou. Default: return false.\n\n    // Registro de callbacks (chamado pelo MIDIHandler):\n    void setMidiCallback(MidiDataCallback cb, void* ctx);\n    void setConnectionCallbacks(ConnectionCallback onConnected,\n                                ConnectionCallback onDisconnected,\n                                void* ctx);\n\nprotected:\n    // Chamar nas subclasses para injetar dados no MIDIHandler:\n    void dispatchMidiData(const uint8_t* data, size_t len);\n    void dispatchConnected();\n    void dispatchDisconnected();\n};\n</code></pre>"},{"location":"api/referencia/#usbconnection","title":"USBConnection","text":"<p>Transporte USB Host. Inclu\u00eddo automaticamente em chips S2/S3/P4.</p> <pre><code>// Uso interno \u2014 n\u00e3o instancie diretamente.\n// Configura\u00e7\u00e3o: Tools &gt; USB Mode \u2192 \"USB Host\"\n</code></pre>"},{"location":"api/referencia/#bleconnection","title":"BLEConnection","text":"<p>Transporte BLE MIDI. Inclu\u00eddo automaticamente se <code>CONFIG_BT_ENABLED</code>.</p> <pre><code>// Uso interno \u2014 n\u00e3o instancie diretamente.\n// Nome configurado via MIDIHandlerConfig::bleName\n</code></pre>"},{"location":"api/referencia/#espnowconnection","title":"ESPNowConnection","text":"<pre><code>#include \"src/ESPNowConnection.h\"\n\nESPNowConnection espNow;\nespNow.begin(int channel = 0);     // 0 = usar canal atual do WiFi\nespNow.addPeer(const uint8_t mac[6]);  // Adicionar peer para unicast\n// isConnected() sempre retorna true\n</code></pre>"},{"location":"api/referencia/#uartconnection","title":"UARTConnection","text":"<pre><code>#include \"src/UARTConnection.h\"\n\nUARTConnection uart;\nuart.begin(HardwareSerial&amp; serial, int rxPin, int txPin);\n// serial: Serial1, Serial2, etc.\n// rxPin, txPin: GPIOs para RX e TX\n// isConnected() sempre retorna true\n</code></pre>"},{"location":"api/referencia/#rtpmidiconnection","title":"RTPMIDIConnection","text":"<pre><code>#include \"src/RTPMIDIConnection.h\"  // Requer AppleMIDI-Library v3.x\n\nRTPMIDIConnection rtpMIDI;\nrtpMIDI.begin(const char* sessionName = \"ESP32 MIDI\");\n// WiFi deve estar conectado ANTES de chamar begin()\n// isConnected() retorna true quando h\u00e1 sess\u00e3o AppleMIDI ativa\n</code></pre>"},{"location":"api/referencia/#ethernetmidiconnection","title":"EthernetMIDIConnection","text":"<pre><code>#include \"src/EthernetMIDIConnection.h\"  // Requer AppleMIDI + Ethernet\n\nEthernetMIDIConnection ethMIDI;\nethMIDI.begin(const uint8_t mac[6]);                          // DHCP\nethMIDI.begin(const uint8_t mac[6], IPAddress staticIP);      // IP est\u00e1tico\nethMIDI.begin(const uint8_t mac[6], IPAddress ip, int csPin); // CS pin customizado\n</code></pre>"},{"location":"api/referencia/#oscconnection","title":"OSCConnection","text":"<pre><code>#include \"src/OSCConnection.h\"  // Requer CNMAT/OSC\n\nOSCConnection osc;\nosc.begin(\n    int localPort,              // Porta UDP local (ex: 8000)\n    IPAddress remoteIP,         // IP do destino (ex: computador com Max/MSP)\n    int remotePort              // Porta UDP do destino (ex: 9000)\n);\n</code></pre> <p>Mapa de endere\u00e7os: <pre><code>/midi/noteon    channel note velocity\n/midi/noteoff   channel note velocity\n/midi/cc        channel controller value\n/midi/pc        channel program\n/midi/pitchbend channel bend\n/midi/aftertouch channel pressure\n</code></pre></p>"},{"location":"api/referencia/#usbdeviceconnection","title":"USBDeviceConnection","text":"<pre><code>#include \"src/USBDeviceConnection.h\"\n// Configura\u00e7\u00e3o: Tools &gt; USB Mode \u2192 \"USB-OTG (TinyUSB)\"\n\nUSBDeviceConnection usbDev(const char* deviceName = \"ESP32 MIDI\");\nusbDev.begin();\n// Deve ser chamado ANTES de midiHandler.begin()\n// isConnected() retorna true quando o host USB estiver conectado\n</code></pre>"},{"location":"api/referencia/#midi2udpconnection","title":"MIDI2UDPConnection","text":"<pre><code>#include \"src/MIDI2UDPConnection.h\"  // Inclui MIDI2Support.h\n\nMIDI2UDPConnection midi2udp;\nmidi2udp.begin(\n    int localPort,    // Porta UDP local (ex: 5006)\n    IPAddress peerIP, // IP do ESP32 parceiro\n    int peerPort      // Porta UDP do parceiro (ex: 5006)\n);\n\nconst UMPResult&amp; r = midi2udp.lastResult();\n// r.valid       \u2192 pacote v\u00e1lido?\n// r.isMIDI2     \u2192 \u00e9 MIDI 2.0 (64-bit)?\n// r.note        \u2192 nota MIDI (0-127)\n// r.velocity16  \u2192 velocidade 16-bit\n// r.value       \u2192 valor 32-bit (CC, PB)\n// r.midi1[3]    \u2192 bytes MIDI 1.0 equivalentes\n</code></pre>"},{"location":"api/referencia/#midi2support-tipos-e-utilitarios","title":"MIDI2Support \u2014 Tipos e Utilit\u00e1rios","text":"<pre><code>#include \"src/MIDI2Support.h\"\n\n// Escalamento\nuint16_t MIDI2Scaler::scale7to16(uint8_t v7);\nuint32_t MIDI2Scaler::scale7to32(uint8_t v7);\nuint32_t MIDI2Scaler::scale14to32(uint16_t v14);\nuint8_t  MIDI2Scaler::scale16to7(uint16_t v16);\nuint8_t  MIDI2Scaler::scale32to7(uint32_t v32);\nuint16_t MIDI2Scaler::scale32to14(uint32_t v32);\n\n// Builder UMP\nUMPWord64 UMPBuilder::noteOn(uint8_t group, uint8_t channel,\n                              uint8_t note, uint16_t velocity16);\nUMPWord64 UMPBuilder::noteOff(uint8_t group, uint8_t channel,\n                               uint8_t note, uint16_t velocity16);\nUMPWord64 UMPBuilder::controlChange(uint8_t group, uint8_t channel,\n                                     uint8_t index, uint32_t value32);\nUMPWord64 UMPBuilder::pitchBend(uint8_t group, uint8_t channel,\n                                 uint32_t value32);\n\n// Parser UMP\nUMPResult UMPParser::parseMIDI2(UMPWord64 pkt);\n</code></pre>"},{"location":"api/referencia/#gingoadapter","title":"GingoAdapter","text":"<pre><code>#include \"src/GingoAdapter.h\"  // Requer Gingoduino \u2265 v0.2.2\n\n// Identificar nome do acorde mais recente\nbool GingoAdapter::identifyLastChord(\n    MIDIHandler&amp; handler,\n    char* outName,\n    size_t nameSize\n);\n\n// Converter notas MIDI para GingoNote\nuint8_t GingoAdapter::midiToGingoNotes(\n    const uint8_t* midiNotes,\n    uint8_t count,\n    GingoNote* outNotes\n);\n\n// Campo harm\u00f4nico (requer GINGODUINO_HAS_FIELD)\n#if defined(GINGODUINO_HAS_FIELD)\nuint8_t GingoAdapter::deduceFieldFromQueue(\n    MIDIHandler&amp; handler,\n    FieldMatch* outFields,\n    uint8_t maxFields\n);\n#endif\n\n// Progress\u00e3o (requer GINGODUINO_HAS_PROGRESSION)\n#if defined(GINGODUINO_HAS_PROGRESSION)\nbool GingoAdapter::identifyProgression(\n    const char* root,\n    ScaleType scale,\n    const char** branches,\n    uint8_t branchCount,\n    ProgressionMatch* out\n);\n#endif\n</code></pre>"},{"location":"api/referencia/#macros-de-feature-detection","title":"Macros de Feature Detection","text":"<pre><code>ESP32_HOST_MIDI_HAS_USB    // 1 se chip suportar USB OTG (S2, S3, P4)\nESP32_HOST_MIDI_HAS_BLE    // 1 se CONFIG_BT_ENABLED\nESP32_HOST_MIDI_HAS_PSRAM  // 1 se CONFIG_SPIRAM ou CONFIG_SPIRAM_SUPPORT\nESP32_HOST_MIDI_HAS_ETH_MAC // 1 se ESP32-P4 (MAC Ethernet nativo)\n</code></pre>"},{"location":"api/referencia/#notas-de-uso","title":"Notas de Uso","text":"<ul> <li><code>midiHandler.task()</code> deve ser chamado em todo <code>loop()</code>, sem bloqueios longos</li> <li><code>addTransport()</code> deve ser chamado antes de <code>begin()</code></li> <li>O m\u00e1ximo de transportes externos \u00e9 4 (built-ins n\u00e3o contam)</li> <li>Ring buffers s\u00e3o thread-safe com <code>portMUX</code> \u2014 seguro para FreeRTOS</li> <li>A fila (<code>getQueue()</code>) \u00e9 v\u00e1lida apenas dentro da itera\u00e7\u00e3o \u2014 n\u00e3o guarde refer\u00eancias al\u00e9m do loop atual</li> </ul>"},{"location":"avancado/hardware/","title":"\ud83d\udd27 Hardware Suportado","text":"<p>Refer\u00eancia completa de chips ESP32, m\u00f3dulos e dispositivos externos compat\u00edveis com ESP32_Host_MIDI.</p>"},{"location":"avancado/hardware/#chips-esp32-por-recurso","title":"Chips ESP32 por Recurso","text":"Chip USB Host BLE USB Device WiFi Ethernet nativo UART ESP-NOW ESP32-S3 \u2705 FS \u2705 \u2705 \u2705 \u274c \u2705 \u2705 ESP32-S2 \u2705 FS \u274c \u2705 \u2705 \u274c \u2705 \u274c ESP32-P4 \u2705 HS \u274c \u2705 \u274c \u2705 \u2705 \u00d75 \u274c ESP32 Classic \u274c \u2705 \u274c \u2705 \u274c \u2705 \u2705 ESP32-C3 \u274c \u2705 \u274c \u2705 \u274c \u2705 \u2705 ESP32-C6 \u274c \u2705 \u274c \u2705 \u274c \u2705 \u2705 ESP32-H2 \u274c \u2705 \u274c \u274c \u274c \u2705 \u2705 <p>FS = Full-Speed (12 Mbps) \u00b7 HS = High-Speed (480 Mbps)</p> <p>W5500 SPI Ethernet</p> <p>O m\u00f3dulo Ethernet W5500 (SPI) funciona em qualquer ESP32 via <code>EthernetMIDIConnection</code>. A coluna \"Ethernet nativo\" refere-se ao MAC Ethernet integrado no chip.</p>"},{"location":"avancado/hardware/#placas-recomendadas","title":"Placas Recomendadas","text":"<pre><code>mindmap\n  root((Placas\\nRecomendadas))\n    LilyGO T-Display-S3\n      ESP32-S3 com PSRAM\n      Display ST7789 1.9\"\n      USB-OTG + BLE + WiFi\n      Bateria LiPo\n      Melhor op\u00e7\u00e3o geral\n    ESP32-S3 DevKit\n      USB Host + BLE + WiFi\n      Sem display\n      Ideal para projetos custom\n    ESP32 DevKit\n      BLE + WiFi + ESP-NOW\n      Sem USB Host\n      Ideal para n\u00f3s ESP-NOW\n    ESP32-P4 EVK\n      USB HS + Ethernet MAC\n      5\u00d7 UART\n      Ideal para est\u00fadio/rack\n    Waveshare ESP32-S3 Zero\n      Ultra compacto\n      USB-C nativo\n      Ideal para controllers</code></pre>"},{"location":"avancado/hardware/#lilygo-t-display-s3-placa-recomendada","title":"LilyGO T-Display-S3 (Placa Recomendada)","text":"<p>A melhor placa para ESP32_Host_MIDI \u2014 tudo em um:</p> Especifica\u00e7\u00e3o Valor Chip ESP32-S3 (dual-core 240 MHz) PSRAM 8 MB OPI PSRAM Flash 16 MB Display ST7789 1.9\" 170\u00d7320 pixels USB USB-C (OTG nativo) Bluetooth BLE 5.0 WiFi 802.11 b/g/n (2,4 GHz) Bateria Carregamento LiPo integrado GPIO 16+ pinos dispon\u00edveis Bot\u00f5es 2\u00d7 bot\u00f5es de usu\u00e1rio <p>Configura\u00e7\u00e3o Arduino IDE: <pre><code>Board: \"LilyGo T-Display-S3\" ou \"ESP32S3 Dev Module\"\nPSRAM: OPI PSRAM\nUSB Mode: USB Host (para teclado)\nUpload Mode: USB-OTG / UART\n</code></pre></p>"},{"location":"avancado/hardware/#esp32-p4-alta-performance","title":"ESP32-P4 \u2014 Alta Performance","text":"<p>O ESP32-P4 \u00e9 o chip mais poderoso da fam\u00edlia ESP32:</p> Especifica\u00e7\u00e3o Valor CPU Dual RISC-V 400 MHz USB High-Speed (480 Mbps) \u2014 hub m\u00faltiplos dispositivos Ethernet MAC nativo (requer PHY externo, ex: LAN8720) UART 5\u00d7 hardware UARTs PSRAM At\u00e9 32 MB Desvantagem Sem WiFi, sem Bluetooth <p>ESP32-P4 + ESP32-C6</p> <p>Para ter WiFi + Ethernet + USB HS ao mesmo tempo, use ESP32-P4 (USB, Ethernet, UART) conectado via UART a um ESP32-C6 (WiFi/BLE) como co-processador.</p>"},{"location":"avancado/hardware/#dispositivos-usb-midi-compativeis","title":"Dispositivos USB MIDI Compat\u00edveis","text":"<p>Qualquer dispositivo USB MIDI 1.0 Class Compliant funciona com USB Host:</p> Categoria Exemplos Teclados controladores Arturia KeyLab, Akai MPK, Native Instruments Komplete Kontrol Pads MIDI Akai MPD, Roland SPD, Native Instruments Maschine Interfaces MIDI iConnectMIDI, Focusrite Scarlett, Roland UM-ONE Controladores DJ Numark NS7, Pioneer DDJ Sopro MIDI Akai EWI, Yamaha WX Pedaleiras Line 6 Helix, Boss MS-3 Instrumentos digitais Roland Aerophone, Casio PX-S <p>Como verificar</p> <p>Se funciona em macOS sem driver \u2192 \u00e9 class-compliant \u2192 funciona com ESP32_Host_MIDI.</p>"},{"location":"avancado/hardware/#modulos-ethernet-compativeis","title":"M\u00f3dulos Ethernet Compat\u00edveis","text":"M\u00f3dulo Chip Interface Alimenta\u00e7\u00e3o W5500 Mini W5500 SPI 3.3V Waveshare W5500 W5500 SPI 3.3V ENC28J60 ENC28J60 SPI 3.3V USR-ES1 W5500 W5500 SPI 3.3V <p>ENC28J60</p> <p>O <code>EthernetMIDIConnection</code> usa a biblioteca <code>Ethernet.h</code> (W5x00). Para ENC28J60, use a biblioteca <code>EthernetENC</code> \u2014 compat\u00edvel com a mesma API.</p>"},{"location":"avancado/hardware/#pinagem-spi-sugerida-por-placa","title":"Pinagem SPI Sugerida por Placa","text":""},{"location":"avancado/hardware/#w5500-com-esp32-classic","title":"W5500 com ESP32 Classic","text":"<pre><code>MOSI \u2192 GPIO 23\nMISO \u2192 GPIO 19\nSCK  \u2192 GPIO 18\nCS   \u2192 GPIO 5\n</code></pre>"},{"location":"avancado/hardware/#w5500-com-esp32-s3","title":"W5500 com ESP32-S3","text":"<pre><code>MOSI \u2192 GPIO 11\nMISO \u2192 GPIO 13\nSCK  \u2192 GPIO 12\nCS   \u2192 GPIO 10\n</code></pre>"},{"location":"avancado/hardware/#w5500-com-esp32-p4","title":"W5500 com ESP32-P4","text":"<pre><code>MOSI \u2192 GPIO (SPI2_MOSI)\nMISO \u2192 GPIO (SPI2_MISO)\nSCK  \u2192 GPIO (SPI2_CLK)\nCS   \u2192 GPIO (qualquer dispon\u00edvel)\n</code></pre>"},{"location":"avancado/hardware/#macros-de-deteccao-em-tempo-de-compilacao","title":"Macros de Detec\u00e7\u00e3o em Tempo de Compila\u00e7\u00e3o","text":"<pre><code>// Verificar suporte de hardware no c\u00f3digo:\n\n#if ESP32_HOST_MIDI_HAS_USB\n    // USB Host dispon\u00edvel \u2014 S2, S3, P4\n#endif\n\n#if ESP32_HOST_MIDI_HAS_BLE\n    // BLE dispon\u00edvel \u2014 ESP32, S3, C3, C6, H2\n    bool connected = midiHandler.isBleConnected();\n#endif\n\n#if ESP32_HOST_MIDI_HAS_PSRAM\n    // PSRAM dispon\u00edvel \u2014 hist\u00f3rico grande\n    midiHandler.enableHistory(1000);\n#endif\n\n#if ESP32_HOST_MIDI_HAS_ETH_MAC\n    // MAC Ethernet nativo \u2014 apenas ESP32-P4\n#endif\n</code></pre>"},{"location":"avancado/hardware/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>MIDI 2.0 / UMP \u2192 \u2014 recursos espec\u00edficos do P4</li> <li>Troubleshooting \u2192 \u2014 problemas comuns de hardware</li> <li>Transportes \u2192 \u2014 qual transporte usar em cada chip</li> </ul>"},{"location":"avancado/midi2-ump/","title":"\ud83d\ude80 MIDI 2.0 / UMP \u2014 Deep Dive","text":"<p>Refer\u00eancia t\u00e9cnica completa sobre MIDI 2.0, Universal MIDI Packets (UMP) e a implementa\u00e7\u00e3o em ESP32_Host_MIDI.</p>"},{"location":"avancado/midi2-ump/#o-que-e-midi-20","title":"O Que \u00e9 MIDI 2.0","text":"<p>O MIDI 2.0 \u00e9 o sucessor do MIDI 1.0 (1983), publicado pela MIDI Manufacturers Association (MMA) em 2020. Mant\u00e9m total retrocompatibilidade com MIDI 1.0 enquanto adiciona:</p> <ul> <li>Velocidade 16-bit (0\u201365535 vs 0\u2013127)</li> <li>Control Change 32-bit (0\u20134.294.967.295 vs 0\u2013127)</li> <li>Pitch Bend 32-bit (maior precis\u00e3o de afina\u00e7\u00e3o)</li> <li>Pressure polir\u00edtmica 32-bit por nota</li> <li>Per-note controllers (pitch bend por nota individualmente)</li> <li>Profile Negotiation \u2014 dispositivos negociam capacidades</li> <li>Property Exchange \u2014 metadados em JSON</li> </ul>"},{"location":"avancado/midi2-ump/#universal-midi-packet-ump","title":"Universal MIDI Packet (UMP)","text":"<p>O MIDI 2.0 usa um novo formato de pacote \u2014 o Universal MIDI Packet \u2014 em vez dos bytes simples do MIDI 1.0:</p> <pre><code>graph LR\n    subgraph MIDI1[\"MIDI 1.0\"]\n        B1[\"Byte 0\\nStatus\"]\n        B2[\"Byte 1\\nData\"]\n        B3[\"Byte 2\\nData\"]\n    end\n\n    subgraph UMP32[\"UMP 32-bit (MIDI 1.0 em UMP)\"]\n        W1[\"Word 0\\n32 bits\\n[MT][Group][Status][Channel][Note][Vel7]\"]\n    end\n\n    subgraph UMP64[\"UMP 64-bit (MIDI 2.0)\"]\n        W2[\"Word 0\\n32 bits\\n[MT][Group][Opcode][Channel][Note][Attr]\"]\n        W3[\"Word 1\\n32 bits\\n[Velocity16][Attribute Data]\"]\n    end\n\n    MIDI1 -.-&gt;|\"encapsular\"| UMP32\n    UMP32 -.-&gt;|\"upgrade\"| UMP64</code></pre>"},{"location":"avancado/midi2-ump/#tipos-de-mensagem-ump","title":"Tipos de Mensagem UMP","text":"C\u00f3digo Tipo Tamanho <code>0x0</code> Utility 32-bit <code>0x1</code> System Real-Time / Common 32-bit <code>0x2</code> MIDI 1.0 Channel Voice 32-bit <code>0x3</code> Data Messages (SysEx7) 64-bit <code>0x4</code> MIDI 2.0 Channel Voice 64-bit <code>0x5</code> Data Messages (SysEx8) 128-bit"},{"location":"avancado/midi2-ump/#opcodes-midi-20-channel-voice-mt0x4","title":"Opcodes MIDI 2.0 Channel Voice (MT=0x4)","text":"Opcode Mensagem Dados Word 1 <code>0x9</code> Note On Velocity 16-bit <code>0x8</code> Note Off Velocity 16-bit <code>0xB</code> Control Change Value 32-bit <code>0xE</code> Pitch Bend Value 32-bit <code>0xC</code> Program Change \u2014 <code>0xD</code> Channel Pressure Value 32-bit <code>0xA</code> Poly Pressure Value 32-bit <code>0x6</code> Per-Note Pitch Bend Value 32-bit <code>0xF</code> Per-Note Management \u2014"},{"location":"avancado/midi2-ump/#escalamento-midi-10-midi-20","title":"Escalamento MIDI 1.0 \u2194 MIDI 2.0","text":"<pre><code>flowchart LR\n    subgraph M1[\"MIDI 1.0\"]\n        V7[\"Vel: 7-bit\\n0\u2013127\"]\n        CC7[\"CC: 7-bit\\n0\u2013127\"]\n        PB14[\"PitchBend: 14-bit\\n0\u201316383\"]\n    end\n\n    subgraph M2[\"MIDI 2.0\"]\n        V16[\"Vel: 16-bit\\n0\u201365535\"]\n        CC32[\"CC: 32-bit\\n0\u20134.29B\"]\n        PB32[\"PitchBend: 32-bit\"]\n    end\n\n    V7 &lt;--&gt;|\"\u00d7512.00\\n(scale7to16)\"| V16\n    CC7 &lt;--&gt;|\"\u00d733.825.421\"| CC32\n    PB14 &lt;--&gt;|\"\u00d765536\\n\u00f716384\"| PB32\n\n    style M1 fill:#37474F,color:#fff\n    style M2 fill:#3F51B5,color:#fff</code></pre>"},{"location":"avancado/midi2-ump/#formulas-de-escalamento","title":"F\u00f3rmulas de Escalamento","text":"<pre><code>// MIDI 1.0 \u2192 MIDI 2.0 (upscale)\nuint16_t vel16 = ((uint32_t)vel7 * 0xFFFF) / 0x7F;\nuint32_t cc32  = ((uint64_t)cc7  * 0xFFFFFFFF) / 0x7F;\nuint32_t pb32  = ((uint64_t)pb14 * 0xFFFFFFFF) / 0x3FFF;\n\n// MIDI 2.0 \u2192 MIDI 1.0 (downscale)\nuint8_t  vel7  = (vel16 * 0x7F + 0x8000) / 0xFFFF;\nuint8_t  cc7   = (cc32  * 0x7F + 0x80000000) / 0xFFFFFFFF;\nuint16_t pb14  = (pb32  * 0x3FFF + 0x80000000) / 0xFFFFFFFF;\n</code></pre>"},{"location":"avancado/midi2-ump/#implementacao-em-esp32_host_midi","title":"Implementa\u00e7\u00e3o em ESP32_Host_MIDI","text":""},{"location":"avancado/midi2-ump/#midi2supporth","title":"MIDI2Support.h","text":"<pre><code>#include \"src/MIDI2Support.h\"\n\n// \u2500\u2500\u2500 Tipos \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nstruct UMPWord64 {\n    uint32_t word0;\n    uint32_t word1;\n};\n\nstruct UMPResult {\n    bool valid;\n    bool isMIDI2;\n    uint8_t msgType;        // Message Type (0x0\u20130x5)\n    uint8_t channel;        // Canal (0\u201315)\n    uint8_t note;           // Nota MIDI (0\u2013127)\n    uint16_t velocity16;    // Velocidade 16-bit (MIDI 2.0)\n    uint32_t value;         // Valor 32-bit (CC, PB)\n    uint8_t midi1[3];       // Equivalente MIDI 1.0 (downscaled)\n};\n\n// \u2500\u2500\u2500 Escalamento \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass MIDI2Scaler {\npublic:\n    static uint16_t scale7to16(uint8_t v7);\n    static uint32_t scale7to32(uint8_t v7);\n    static uint32_t scale14to32(uint16_t v14);\n    static uint8_t  scale16to7(uint16_t v16);\n    static uint8_t  scale32to7(uint32_t v32);\n    static uint16_t scale32to14(uint32_t v32);\n};\n\n// \u2500\u2500\u2500 Builder \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass UMPBuilder {\npublic:\n    static UMPWord64 noteOn(uint8_t group, uint8_t channel,\n                             uint8_t note, uint16_t velocity16);\n    static UMPWord64 noteOff(uint8_t group, uint8_t channel,\n                              uint8_t note, uint16_t velocity16);\n    static UMPWord64 controlChange(uint8_t group, uint8_t channel,\n                                    uint8_t index, uint32_t value32);\n    static UMPWord64 pitchBend(uint8_t group, uint8_t channel,\n                                uint32_t value32);\n};\n\n// \u2500\u2500\u2500 Parser \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass UMPParser {\npublic:\n    static UMPResult parseMIDI2(UMPWord64 pkt);\n};\n</code></pre>"},{"location":"avancado/midi2-ump/#exemplo-completo-construir-e-parsear-ump","title":"Exemplo Completo \u2014 Construir e Parsear UMP","text":"<pre><code>#include \"src/MIDI2Support.h\"\n\nvoid exemploUMP() {\n    // 1. Nota com velocidade MIDI 1.0 (7-bit)\n    uint8_t vel7 = 100;\n\n    // 2. Escalar para MIDI 2.0 (16-bit)\n    uint16_t vel16 = MIDI2Scaler::scale7to16(vel7);\n    Serial.printf(\"vel7=%d \u2192 vel16=%u (%.1f%%)\\n\",\n        vel7, vel16, vel16 / 65535.0f * 100.0f);\n\n    // 3. Construir pacote UMP (NoteOn, grupo 0, canal 0, C4=60)\n    UMPWord64 pkt = UMPBuilder::noteOn(0, 0, 60, vel16);\n    Serial.printf(\"UMP Word0: 0x%08X\\n\", pkt.word0);\n    Serial.printf(\"UMP Word1: 0x%08X\\n\", pkt.word1);\n\n    // 4. Parsear de volta\n    UMPResult r = UMPParser::parseMIDI2(pkt);\n    Serial.printf(\"Parse: note=%d vel16=%u vel7=%d\\n\",\n        r.note, r.velocity16, r.midi1[2]);\n}\n</code></pre> <p>Sa\u00edda: <pre><code>vel7=100 \u2192 vel16=51380 (78.4%)\nUMP Word0: 0x40093C00\nUMP Word1: 0xC8B40000\nParse: note=60 vel16=51380 vel7=100\n</code></pre></p>"},{"location":"avancado/midi2-ump/#midi2udpconnection-protocolo","title":"MIDI2UDPConnection \u2014 Protocolo","text":"<p>Protocolo customizado ESP32\u2192ESP32 de 12 bytes:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 55 4D 50 32  \u2502  Word0 (4 bytes BE)  \u2502  Word1 (4 bytes BE)      \u2502\n\u2502  \"UMP2\"      \u2502  Header UMP          \u2502  Velocidade 16-bit        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Exemplo NoteOn C4, vel7=100: <pre><code>55 4D 50 32   \u2190 Magic \"UMP2\"\n40 09 3C 00   \u2190 MT=4, opcode=9 (NoteOn), ch=0, note=60\nC8 B4 00 00   \u2190 vel16 = 51380 = 0xC8B4\n</code></pre></p>"},{"location":"avancado/midi2-ump/#status-do-midi-20-na-biblioteca","title":"Status do MIDI 2.0 na Biblioteca","text":"Feature Status UMP 32-bit (MIDI 1.0 in UMP) \u2705 Implementado UMP 64-bit (MIDI 2.0) \u2705 NoteOn, NoteOff, CC, PB Escalamento 7\u219216, 7\u219232, 14\u219232 \u2705 MIDI2UDPConnection (ESP32\u2194ESP32) \u2705 Profile Negotiation \ud83d\udd04 Futuro Property Exchange \ud83d\udd04 Futuro MIDI-CI \ud83d\udd04 Futuro"},{"location":"avancado/midi2-ump/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>MIDI 2.0 UDP \u2192 \u2014 usar o transporte</li> <li>Exemplo MIDI 2.0 \u2192 \u2014 sketch com display</li> <li>Roadmap \u2192 \u2014 MIDI-CI e Profile Negotiation</li> </ul>"},{"location":"avancado/troubleshooting/","title":"\ud83d\udd0d Troubleshooting","text":"<p>Solu\u00e7\u00f5es para os problemas mais comuns ao usar ESP32_Host_MIDI.</p>"},{"location":"avancado/troubleshooting/#usb-host","title":"USB Host","text":""},{"location":"avancado/troubleshooting/#teclado-usb-nao-e-detectado","title":"\u274c Teclado USB n\u00e3o \u00e9 detectado","text":"<p>Sintomas: Serial Monitor n\u00e3o mostra nada ao pressionar teclas.</p> <p>Verifica\u00e7\u00f5es:</p> <ol> <li> <p>USB Mode correto? <pre><code>Arduino IDE \u2192 Tools \u2192 USB Mode \u2192 \"USB Host\"\n</code></pre>    Esta op\u00e7\u00e3o s\u00f3 aparece para ESP32-S3, S2 ou P4.</p> </li> <li> <p>Placa correta selecionada?    Apenas ESP32-S3, S2 e P4 t\u00eam USB-OTG. ESP32 Classic n\u00e3o suporta.</p> </li> <li> <p>Cabo OTG correto?</p> </li> <li>Use um cabo USB-OTG host (micro-A ou C para USB-A f\u00eamea)</li> <li>N\u00e3o use um cabo de dados normal \u2014 a pinagem \u00e9 diferente</li> <li> <p>Verifique se o cabo suporta dados (n\u00e3o apenas carga)</p> </li> <li> <p>Teclado \u00e9 class-compliant?    Teste conectando ao macOS \u2014 se reconhecer sem driver, \u00e9 class-compliant.</p> </li> <li> <p>Alimenta\u00e7\u00e3o suficiente? <pre><code>Serial.printf(\"Tens\u00e3o USB: %.2fV\\n\", /* medir na linha VBUS */);\n</code></pre>    Dispositivos USB MIDI precisam de pelo menos 100 mA a 5V.</p> </li> </ol>"},{"location":"avancado/troubleshooting/#usb-mode-nao-aparece-no-menu-tools","title":"\u274c \"USB Mode\" n\u00e3o aparece no menu Tools","text":"<p>Causa: Placa selecionada n\u00e3o suporta USB-OTG.</p> <p>Solu\u00e7\u00e3o: Mude para \"LilyGo T-Display-S3\", \"ESP32-S3 Dev Module\", ou outra placa S3/S2/P4.</p>"},{"location":"avancado/troubleshooting/#upload-falha-apos-selecionar-usb-host","title":"\u274c Upload falha ap\u00f3s selecionar \"USB Host\"","text":"<p>Causa: O modo USB Host muda o comportamento do USB CDC.</p> <p>Solu\u00e7\u00f5es:</p> <ol> <li>Pressione o bot\u00e3o BOOT + RST para entrar em modo bootloader</li> <li>Ou use o modo de upload via UART (n\u00e3o OTG): conecte via adaptador USB-UART</li> <li>Ap\u00f3s o upload, desconecte/reconecte ou pressione RST</li> </ol>"},{"location":"avancado/troubleshooting/#ble-midi","title":"BLE MIDI","text":""},{"location":"avancado/troubleshooting/#dispositivo-ble-nao-aparece-no-iosmacos","title":"\u274c Dispositivo BLE n\u00e3o aparece no iOS/macOS","text":"<p>Sintomas: O nome configurado n\u00e3o aparece na lista de dispositivos Bluetooth.</p> <p>Verifica\u00e7\u00f5es:</p> <ol> <li> <p>Bluetooth habilitado no sdkconfig? <pre><code>Arduino IDE \u2192 Tools \u2192 Partition Scheme \u2192 \"Default 4MB with spiffs\"\n</code></pre>    Certifique-se de usar uma partition scheme que inclua BLE (&gt;1.5 MB de app).</p> </li> <li> <p>Chip suporta BLE?    ESP32-S2 e ESP32-P4 n\u00e3o t\u00eam Bluetooth. Use ESP32, S3, C3, ou C6.</p> </li> <li> <p>Verificar a macro: <pre><code>#if ESP32_HOST_MIDI_HAS_BLE\n    Serial.println(\"BLE dispon\u00edvel\");\n#else\n    Serial.println(\"BLE N\u00c3O dispon\u00edvel neste chip\");\n#endif\n</code></pre></p> </li> <li> <p>Advertising iniciado? <pre><code>midiHandler.begin();\n// O BLE come\u00e7a a anunciar automaticamente ap\u00f3s begin()\ndelay(1000);\nSerial.println(\"BLE advertising...\");\n</code></pre></p> </li> <li> <p>Conflito de UUID?    Se outro dispositivo BLE com o mesmo nome estiver pr\u00f3ximo, pode conflitar.    Mude <code>cfg.bleName</code> para um nome \u00fanico.</p> </li> </ol>"},{"location":"avancado/troubleshooting/#ble-desconecta-frequentemente","title":"\u274c BLE desconecta frequentemente","text":"<p>Causas poss\u00edveis:</p> <ul> <li>Dist\u00e2ncia &gt; 15 m (paredes reduzem alcance)</li> <li>Interfer\u00eancia de outros dispositivos 2,4 GHz (WiFi, microondas)</li> <li>Alimenta\u00e7\u00e3o insuficiente (queda de tens\u00e3o no pico BLE)</li> </ul> <p>Solu\u00e7\u00f5es:</p> <ul> <li>Adicionar capacitor 100\u00b5F na alimenta\u00e7\u00e3o do ESP32</li> <li>Reduzir pot\u00eancia do WiFi se estiver usando WiFi + BLE simultaneamente</li> <li>O BLE reinicia o advertising automaticamente \u2014 sem a\u00e7\u00e3o necess\u00e1ria no c\u00f3digo</li> </ul>"},{"location":"avancado/troubleshooting/#rtp-midi-wifi","title":"RTP-MIDI (WiFi)","text":""},{"location":"avancado/troubleshooting/#esp32-nao-aparece-em-audio-midi-setup","title":"\u274c ESP32 n\u00e3o aparece em Audio MIDI Setup","text":"<p>Verifica\u00e7\u00f5es:</p> <ol> <li> <p>ESP32 e Mac na mesma rede WiFi? <pre><code>Serial.printf(\"IP: %s\\n\", WiFi.localIP().toString().c_str());\n</code></pre>    Confirme que o IP \u00e9 da mesma sub-rede (ex: 192.168.1.x / 192.168.1.x).</p> </li> <li> <p>Firewall do macOS bloqueando mDNS?    Verifique em: System Settings \u2192 Network \u2192 Firewall \u2192 Allow incoming connections.</p> </li> <li> <p>AppleMIDI-Library v3.x instalada? <pre><code>Manage Libraries \u2192 \"AppleMIDI\" \u2192 vers\u00e3o \u2265 3.0.0\n</code></pre></p> </li> <li> <p>WiFi conectado ANTES de rtpMIDI.begin()? <pre><code>WiFi.begin(ssid, pass);\nwhile (WiFi.status() != WL_CONNECTED) delay(500);  // \u2190 Esperar!\nrtpMIDI.begin(\"Meu ESP32\");  // \u2190 S\u00f3 depois\n</code></pre></p> </li> <li> <p>mDNS ativo?    A biblioteca AppleMIDI usa MDNS. Verifique se seu router n\u00e3o bloqueia mDNS (multicast).</p> </li> </ol>"},{"location":"avancado/troubleshooting/#rtp-midi-conecta-mas-sem-som-no-daw","title":"\u274c RTP-MIDI conecta mas sem som no DAW","text":"<p>Causa: A sess\u00e3o de rede precisa ser habilitada manualmente no Audio MIDI Setup.</p> <p>Solu\u00e7\u00e3o: 1. Audio MIDI Setup \u2192 Network \u2192 selecione a sess\u00e3o \u2192 clique Connect 2. No DAW: verifique se a porta MIDI \"Meu ESP32\" est\u00e1 habilitada como input</p>"},{"location":"avancado/troubleshooting/#uart-din-5","title":"UART / DIN-5","text":""},{"location":"avancado/troubleshooting/#nenhuma-mensagem-recebida-via-din-5","title":"\u274c Nenhuma mensagem recebida via DIN-5","text":"<p>Verifica\u00e7\u00f5es:</p> <ol> <li> <p>Pinos RX/TX corretos? <pre><code>uartMIDI.begin(Serial1, /*RX=*/16, /*TX=*/17);\n// Confirme que o cabo MIDI est\u00e1 em MIDI IN do instrumento\n// e conectado ao pino RX do ESP32\n</code></pre></p> </li> <li> <p>Optoacoplador corretamente cabeado?    Teste sem opto: conecte o pino de sa\u00edda do opto diretamente a 3.3V via resistor 1k\u03a9.    Se o RX detectar HIGH, o pino est\u00e1 funcionando.</p> </li> <li> <p>Baud rate correto?    MIDI usa 31250 bps \u2014 n\u00e3o confundir com 31200, 38400 ou outros valores similares.</p> </li> <li> <p>Instrumento enviando MIDI?    Teste com outro dispositivo (computador + MIDI interface) para confirmar que o instrumento envia MIDI.</p> </li> <li> <p>GPIO 0 n\u00e3o est\u00e1 sendo usado como RX?    GPIO 0 \u00e9 o bot\u00e3o de boot \u2014 evite usar para UART.</p> </li> </ol>"},{"location":"avancado/troubleshooting/#psram","title":"PSRAM","text":""},{"location":"avancado/troubleshooting/#psram-nao-e-detectada-enablehistory-falha","title":"\u274c PSRAM n\u00e3o \u00e9 detectada / enableHistory() falha","text":"<p>Verifica\u00e7\u00f5es:</p> <ol> <li> <p>PSRAM habilitada no Arduino IDE? <pre><code>Tools \u2192 PSRAM \u2192 \"OPI PSRAM\" (T-Display-S3)\n             ou \"Quad PSRAM\" (outros S3)\n</code></pre></p> </li> <li> <p>Verificar disponibilidade: <pre><code>Serial.printf(\"PSRAM: %u bytes\\n\", ESP.getPsramSize());\nif (ESP.getPsramSize() == 0) {\n    Serial.println(\"PSRAM n\u00e3o detectada!\");\n}\n</code></pre></p> </li> <li> <p>Macro correta: <pre><code>#if ESP32_HOST_MIDI_HAS_PSRAM\n    Serial.println(\"PSRAM dispon\u00edvel\");\n#else\n    Serial.println(\"PSRAM N\u00c3O dispon\u00edvel\");\n#endif\n</code></pre></p> </li> </ol>"},{"location":"avancado/troubleshooting/#compilacao","title":"Compila\u00e7\u00e3o","text":""},{"location":"avancado/troubleshooting/#error-map-was-not-declared","title":"\u274c \"error: 'map' was not declared\"","text":"<p>Causa: <code>#include &lt;map&gt;</code> faltando em algum header.</p> <p>Solu\u00e7\u00e3o: Este bug foi corrigido em vers\u00f5es recentes. Atualize a biblioteca: <pre><code>Manage Libraries \u2192 ESP32_Host_MIDI \u2192 Update\n</code></pre></p>"},{"location":"avancado/troubleshooting/#addtransport-limit-exceeded","title":"\u274c \"addTransport() limit exceeded\"","text":"<p>Causa: Voc\u00ea registrou mais de 4 transportes externos via <code>addTransport()</code>.</p> <p>Solu\u00e7\u00e3o: O limite \u00e9 4 transportes externos. USB, BLE e ESP-NOW built-in n\u00e3o contam. Combine transportes ou reduza o n\u00famero de transportes externos.</p>"},{"location":"avancado/troubleshooting/#debug-callback-raw-midi","title":"Debug \u2014 Callback Raw MIDI","text":"<p>Para inspecionar bytes brutos antes do parsing:</p> <pre><code>void onRaw(const uint8_t* raw, size_t len, const uint8_t* midi3) {\n    Serial.printf(\"RAW [%d bytes]: \", (int)len);\n    for (size_t i = 0; i &lt; len; i++) {\n        Serial.printf(\"%02X \", raw[i]);\n    }\n    Serial.printf(\"| MIDI: %02X %02X %02X\\n\",\n        midi3[0], midi3[1], midi3[2]);\n}\n\nvoid setup() {\n    midiHandler.setRawMidiCallback(onRaw);\n    midiHandler.begin();\n}\n</code></pre>"},{"location":"avancado/troubleshooting/#abrir-uma-issue","title":"Abrir uma Issue","text":"<p>Se o problema persiste ap\u00f3s todas as verifica\u00e7\u00f5es:</p> <ol> <li>Anote a vers\u00e3o da biblioteca (<code>library.properties</code>)</li> <li>Anote o chip e a placa</li> <li>Copie o Serial Monitor (com debug raw callback)</li> <li>Abra uma issue em github.com/sauloverissimo/ESP32_Host_MIDI/issues</li> </ol>"},{"location":"avancado/troubleshooting/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Hardware Suportado \u2192 \u2014 verificar compatibilidade do chip</li> <li>API \u2192 \u2014 conferir assinaturas corretas</li> <li>Primeiros Passos \u2192 \u2014 voltar ao b\u00e1sico</li> </ul>"},{"location":"exemplos/esp-now-jam/","title":"\ud83d\udce1 ESP-NOW Jam","text":"<p>O exemplo <code>T-Display-S3-ESP-NOW-Jam</code> cria um jam colaborativo sem fio entre m\u00faltiplos ESP32. Cada m\u00fasico tem seu pr\u00f3prio ESP32; todos os eventos MIDI s\u00e3o compartilhados instantaneamente via ESP-NOW \u2014 sem router, sem lat\u00eancia de WiFi.</p>"},{"location":"exemplos/esp-now-jam/#conceito","title":"Conceito","text":"<pre><code>graph LR\n    subgraph JAM[\"\ud83c\udfb8 Jam Session\"]\n        P1[\"\ud83c\udfb9 Jogador 1\\nT-Display-S3\\n(Teclado USB)\"]\n        P2[\"\ud83e\udd41 Jogador 2\\nT-Display-S3\\n(Pad MIDI)\"]\n        P3[\"\ud83c\udfb8 Jogador 3\\nT-Display-S3\\n(Baixo MIDI)\"]\n    end\n\n    P1 &lt;--&gt;|\"ESP-NOW\\n&lt; 5 ms\"| P2\n    P1 &lt;--&gt;|\"ESP-NOW\\n&lt; 5 ms\"| P3\n    P2 &lt;--&gt;|\"ESP-NOW\\n&lt; 5 ms\"| P3\n\n    style JAM fill:#1A237E,color:#fff,stroke:#283593</code></pre> <p>Todos os ESP32 est\u00e3o no mesmo canal WiFi. Quando qualquer um toca uma nota, ela \u00e9 enviada em broadcast para todos os outros \u2014 e aparece no display de cada um.</p>"},{"location":"exemplos/esp-now-jam/#hardware-necessario","title":"Hardware Necess\u00e1rio","text":"Por participante Detalhe Placa LilyGO T-Display-S3 (ou qualquer ESP32) Instrumento Qualquer USB MIDI class-compliant Cabo USB-OTG"},{"location":"exemplos/esp-now-jam/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/ESPNowConnection.h\"\n// Tools &gt; USB Mode \u2192 \"USB Host\"\n\n// Canal WiFi \u2014 DEVE ser o mesmo em TODOS os ESP32 do jam\nconst int WIFI_CHANNEL = 11;\n\nESPNowConnection espNow;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    // Iniciar ESP-NOW no canal especificado\n    espNow.begin(WIFI_CHANNEL);\n\n    // Registrar e iniciar\n    midiHandler.addTransport(&amp;espNow);\n\n    MIDIHandlerConfig cfg;\n    cfg.bleName = \"Jam Node\";\n    midiHandler.begin(cfg);\n\n    // Mostrar MAC pr\u00f3prio (para adicionar como peer em outros ESP32)\n    Serial.printf(\"Meu MAC: %s\\n\", WiFi.macAddress().c_str());\n    Serial.println(\"ESP-NOW Jam pronto! Canal: \" + String(WIFI_CHANNEL));\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        // Exibir evento (local ou recebido via ESP-NOW de outro participante)\n        Serial.printf(\"[JAM] %s %s vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.velocity);\n\n        // No display: mostrar nota + quem tocou\n    }\n}\n</code></pre>"},{"location":"exemplos/esp-now-jam/#descobrir-ipsmacs-dos-participantes","title":"Descobrir IPs/MACs dos Participantes","text":"<p>Cada ESP32 deve imprimir seu MAC no Serial Monitor ao iniciar:</p> <pre><code>Meu MAC: AA:BB:CC:DD:EE:01   \u2190 ESP32 do Jogador 1\nMeu MAC: AA:BB:CC:DD:EE:02   \u2190 ESP32 do Jogador 2\n</code></pre> <p>Em modo broadcast, todos recebem de todos automaticamente \u2014 sem precisar adicionar MACs.</p> <p>Para modo unicast (enviar para um peer espec\u00edfico):</p> <pre><code>uint8_t peerMAC[] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x02};\nespNow.addPeer(peerMAC);\n</code></pre>"},{"location":"exemplos/esp-now-jam/#regras-do-jam","title":"Regras do Jam","text":"<ol> <li>Mesmo canal WiFi em todos os ESP32 (ex: canal 11)</li> <li>Sem router necess\u00e1rio \u2014 os ESP32 se comunicam diretamente</li> <li>Alcance ~200 m em linha de vis\u00e3o</li> <li>Lat\u00eancia 1\u20135 ms \u2014 impercept\u00edvel musicalmente</li> </ol>"},{"location":"exemplos/esp-now-jam/#jam-usb-ble","title":"Jam + USB + BLE","text":"<p>Voc\u00ea pode combinar ESP-NOW com outros transportes no mesmo sketch:</p> <pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/ESPNowConnection.h\"\n\nESPNowConnection espNow;\n\nvoid setup() {\n    espNow.begin(11);\n    midiHandler.addTransport(&amp;espNow);\n\n    MIDIHandlerConfig cfg;\n    cfg.bleName = \"Jam Node\";\n    midiHandler.begin(cfg);\n    // Teclado USB + iPhone BLE + ESP-NOW \u2014 tudo ao mesmo tempo!\n}\n</code></pre>"},{"location":"exemplos/esp-now-jam/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>ESP-NOW \u2192 \u2014 detalhes do transporte</li> <li>USB Host \u2192 \u2014 conectar teclado ao jam</li> <li>T-Display-S3 \u2192 \u2014 adicionar display ao jam</li> </ul>"},{"location":"exemplos/ethernet-midi/","title":"\ud83d\udd17 Ethernet MIDI","text":"<p>O exemplo <code>Ethernet-MIDI</code> implementa um hub MIDI sobre Ethernet cabeada (W5500 SPI), usando o protocolo AppleMIDI (RTP-MIDI). Ideal para racks de est\u00fadio e instala\u00e7\u00f5es com rede gerenciada.</p>"},{"location":"exemplos/ethernet-midi/#hardware-necessario","title":"Hardware Necess\u00e1rio","text":"Componente Detalhe ESP32 (qualquer) ESP32, S3, S2, P4... M\u00f3dulo W5500 SPI Ethernet (ex: W5500 Mini) Cabo RJ-45 Ethernet para switch/router"},{"location":"exemplos/ethernet-midi/#conexao-w5500-esp32","title":"Conex\u00e3o W5500 \u2194 ESP32","text":"W5500 ESP32 GPIO Notas MOSI 23 SPI MOSI MISO 19 SPI MISO SCK 18 SPI Clock CS (SCS) 5 Chip Select RST 4 Reset (opcional) VCC 3.3V Alimenta\u00e7\u00e3o GND GND Terra <p>W5500 com ESP32-S3</p> <p>Para ESP32-S3, use os pinos SPI2: MOSI=11, MISO=13, SCK=12, CS=10.</p>"},{"location":"exemplos/ethernet-midi/#pre-requisito","title":"Pr\u00e9-requisito","text":"<pre><code>Manage Libraries \u2192\n  \"AppleMIDI\" \u2192 Arduino-AppleMIDI-Library by lathoub (v3.x)\n  \"Ethernet\" \u2192 Ethernet by Arduino (ou compat\u00edvel com W5500)\n</code></pre>"},{"location":"exemplos/ethernet-midi/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;SPI.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/EthernetMIDIConnection.h\"\n\n// MAC \u00fanico para o dispositivo (escolha qualquer valor \u00fanico na rede)\nstatic const uint8_t MAC[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };\n\n// Pinos SPI para W5500\n#define ETH_CS_PIN 5\n\nEthernetMIDIConnection ethMIDI;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    Serial.println(\"Iniciando Ethernet MIDI...\");\n\n    // Registrar ANTES de begin()\n    midiHandler.addTransport(&amp;ethMIDI);\n\n    // DHCP autom\u00e1tico\n    ethMIDI.begin(MAC);\n\n    // Ou IP est\u00e1tico:\n    // ethMIDI.begin(MAC, IPAddress(192, 168, 1, 100));\n\n    midiHandler.begin();\n\n    Serial.printf(\"Ethernet IP: %s\\n\",\n        Ethernet.localIP().toString().c_str());\n    Serial.println(\"Configure Audio MIDI Setup no macOS:\");\n    Serial.printf(\"  Host: %s  Porta: 5004\\n\",\n        Ethernet.localIP().toString().c_str());\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"[ETH-MIDI] %s %s ch=%d vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.channel,\n            ev.velocity);\n    }\n}\n</code></pre>"},{"location":"exemplos/ethernet-midi/#configurar-no-macos","title":"Configurar no macOS","text":"<p>Como o W5500 n\u00e3o suporta mDNS, configure o IP manualmente:</p> <ol> <li>Audio MIDI Setup \u2192 Window \u2192 Show MIDI Studio</li> <li>Clique em Network</li> <li>Em \"My Sessions\" \u2192 + \u2192 criar nova sess\u00e3o</li> <li>Em \"Directory\" \u2192 + \u2192 Host: [IP do ESP32] | Port: 5004</li> <li>Selecione a sess\u00e3o \u2192 Connect</li> </ol>"},{"location":"exemplos/ethernet-midi/#bridge-uart-ethernet-rack-de-estudio","title":"Bridge UART + Ethernet (Rack de Est\u00fadio)","text":"<p>Conecte um sintetizador vintage via DIN-5 ao ESP32, que o publica na rede Ethernet para o DAW:</p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/UARTConnection.h\"\n#include \"src/EthernetMIDIConnection.h\"\n\nUARTConnection uartMIDI;\nEthernetMIDIConnection ethMIDI;\nconst uint8_t MAC[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };\n\nvoid setup() {\n    uartMIDI.begin(Serial1, 16, 17);     // DIN-5\n    ethMIDI.begin(MAC, IPAddress(192, 168, 1, 50));\n\n    midiHandler.addTransport(&amp;uartMIDI);\n    midiHandler.addTransport(&amp;ethMIDI);\n    midiHandler.begin();\n\n    // Bridge autom\u00e1tico! Qualquer MIDI do DIN-5 vai para Ethernet e vice-versa.\n}\n\nvoid loop() { midiHandler.task(); }\n</code></pre>"},{"location":"exemplos/ethernet-midi/#latencia-tipica","title":"Lat\u00eancia T\u00edpica","text":"Ambiente Lat\u00eancia Jitter WiFi dom\u00e9stico 8\u201325 ms \u00b15 ms Ethernet cabeada 2\u20138 ms &lt; 1 ms Ethernet gerenciada (QoS) 1\u20133 ms &lt; 0.5 ms <p>A Ethernet \u00e9 mais previs\u00edvel e consistente \u2014 fundamental para timing musical preciso em est\u00fadio.</p>"},{"location":"exemplos/ethernet-midi/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Ethernet MIDI \u2192 \u2014 detalhes do transporte</li> <li>UART / DIN-5 \u2192 \u2014 adicionar porta DIN-5</li> <li>RTP-MIDI WiFi \u2192 \u2014 vers\u00e3o sem fio com mDNS</li> </ul>"},{"location":"exemplos/midi2-udp/","title":"\ud83d\ude80 MIDI 2.0 UDP","text":"<p>O exemplo <code>T-Display-S3-MIDI2-UDP</code> demonstra comunica\u00e7\u00e3o MIDI 2.0 end-to-end entre dois ESP32: um envia via teclado USB com resolu\u00e7\u00e3o de 16-bit, o outro recebe e exibe a barra de velocidade em alta resolu\u00e7\u00e3o.</p>"},{"location":"exemplos/midi2-udp/#conceito","title":"Conceito","text":"<pre><code>flowchart LR\n    subgraph A[\"ESP32-A (Sender)\"]\n        KB[\"\ud83c\udfb9 Teclado USB\"]\n        H1[\"MIDIHandler\"]\n        SC[\"MIDI2Scaler\\nscale7to16()\"]\n        SEND[\"MIDI2UDPConnection\\nsend UMP\"]\n    end\n\n    subgraph B[\"ESP32-B (Receiver)\"]\n        RECV[\"MIDI2UDPConnection\\nrecv UMP\"]\n        H2[\"MIDIHandler\\n(downscale autom\u00e1tico)\"]\n        DISP[\"\ud83d\udda5\ufe0f Display\\nbarra vel. 16-bit\"]\n    end\n\n    KB --&gt; H1 --&gt; SC --&gt; SEND\n    SEND --&gt;|\"UDP WiFi\\n12 bytes / evento\"| RECV\n    RECV --&gt; H2 --&gt; DISP</code></pre>"},{"location":"exemplos/midi2-udp/#hardware","title":"Hardware","text":"Componente Quantidade Detalhe LilyGO T-Display-S3 2 Mesma rede WiFi Teclado USB MIDI 1 Para o ESP32-A Cabo USB-OTG 1 Para o ESP32-A"},{"location":"exemplos/midi2-udp/#codigo-esp32-a-sender-com-teclado-usb","title":"C\u00f3digo \u2014 ESP32-A (Sender com teclado USB)","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/MIDI2Support.h\"\n#include \"src/MIDI2UDPConnection.h\"\n// Tools &gt; USB Mode \u2192 \"USB Host\"\n\nconst char* SSID     = \"SeuSSID\";\nconst char* PASSWORD = \"SuaSenha\";\nIPAddress   PEER_IP  = IPAddress(192, 168, 1, 21);  // IP do ESP32-B\nconst int   PORT     = 5006;\n\nMIDI2UDPConnection midi2udp;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    WiFi.begin(SSID, PASSWORD);\n    while (WiFi.status() != WL_CONNECTED) delay(500);\n    Serial.printf(\"Meu IP: %s\\n\", WiFi.localIP().toString().c_str());\n\n    midi2udp.begin(PORT, PEER_IP, PORT);\n    midiHandler.addTransport(&amp;midi2udp);\n    midiHandler.begin();\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    // Eventos do teclado USB s\u00e3o automaticamente enviados via MIDI2UDP\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        if (ev.status == \"NoteOn\" &amp;&amp; ev.velocity &gt; 0) {\n            // Escalar velocidade para 16 bits e logar\n            uint16_t vel16 = MIDI2Scaler::scale7to16(ev.velocity);\n            Serial.printf(\"[USB\u2192UDP] %s vel7=%d vel16=%u\\n\",\n                ev.noteOctave.c_str(), ev.velocity, vel16);\n        }\n    }\n}\n</code></pre>"},{"location":"exemplos/midi2-udp/#codigo-esp32-b-receiver-com-display","title":"C\u00f3digo \u2014 ESP32-B (Receiver com display)","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/MIDI2Support.h\"\n#include \"src/MIDI2UDPConnection.h\"\n// Tools &gt; USB Mode \u2192 \"USB Host\" (ou outro)\n\nconst char* SSID     = \"SeuSSID\";\nconst char* PASSWORD = \"SuaSenha\";\nIPAddress   PEER_IP  = IPAddress(192, 168, 1, 20);  // IP do ESP32-A\nconst int   PORT     = 5006;\n\nMIDI2UDPConnection midi2udp;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    WiFi.begin(SSID, PASSWORD);\n    while (WiFi.status() != WL_CONNECTED) delay(500);\n    Serial.printf(\"Meu IP: %s\\n\", WiFi.localIP().toString().c_str());\n\n    midi2udp.begin(PORT, PEER_IP, PORT);\n    midiHandler.addTransport(&amp;midi2udp);\n    midiHandler.begin();\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        // ev.velocity cont\u00e9m valores MIDI 1.0 (downscaled para 7-bit)\n        Serial.printf(\"[UDP\u2192MIDI] %s vel7=%d\\n\",\n            ev.noteOctave.c_str(), ev.velocity);\n\n        // Acessar valores MIDI 2.0 originais:\n        const UMPResult&amp; r = midi2udp.lastResult();\n        if (r.valid) {\n            float pct = r.velocity16 / 65535.0f * 100.0f;\n            Serial.printf(\"           vel16=%u (%.1f%%)\\n\",\n                r.velocity16, pct);\n\n            // No display real: barra de progresso com pct\n        }\n    }\n}\n</code></pre>"},{"location":"exemplos/midi2-udp/#protocolo-midi2udp","title":"Protocolo MIDI2UDP","text":"<p>Cada pacote UDP tem exatamente 12 bytes:</p> <pre><code>[55 4D 50 32]  Magic \"UMP2\"\n[XX XX XX XX]  UMP Word 0 (big-endian)\n[XX XX XX XX]  UMP Word 1 (big-endian, = 00000000 para 32-bit)\n</code></pre> <p>Exemplo para NoteOn C4, vel=100:</p> <pre><code>Magic:  55 4D 50 32\nWord0:  49 00 3C 00   \u2190 MT=4 (MIDI2 voice), ch=0, opcode=9 (NoteOn), note=60\nWord1:  C8 5C 00 00   \u2190 vel16 = 0xC85C = 51292 (escala de vel7=100)\n</code></pre>"},{"location":"exemplos/midi2-udp/#galeria","title":"Galeria","text":"T-Display-S3-MIDI2-UDP \u2014 barra de velocidade de 16-bit mostrando resolu\u00e7\u00e3o MIDI 2.0"},{"location":"exemplos/midi2-udp/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>MIDI 2.0 / UMP \u2192 \u2014 detalhes do transporte</li> <li>MIDI 2.0 Deep Dive \u2192 \u2014 especifica\u00e7\u00e3o completa UMP</li> <li>OSC Bridge \u2192 \u2014 alternativa para Max/MSP</li> </ul>"},{"location":"exemplos/osc-bridge/","title":"\ud83c\udfa8 OSC Bridge","text":"<p>O exemplo <code>T-Display-S3-OSC</code> implementa uma bridge bidirecional OSC \u2194 MIDI: eventos do teclado USB s\u00e3o enviados como mensagens OSC para o computador, e mensagens OSC do computador s\u00e3o convertidas em MIDI e exibidas no display.</p>"},{"location":"exemplos/osc-bridge/#hardware-necessario","title":"Hardware Necess\u00e1rio","text":"Componente Detalhe Placa LilyGO T-Display-S3 Teclado Qualquer USB MIDI class-compliant Cabo USB-OTG Rede WiFi (mesma rede que o computador)"},{"location":"exemplos/osc-bridge/#pre-requisito","title":"Pr\u00e9-requisito","text":"<pre><code>Manage Libraries \u2192 \"OSC\" \u2192 OSC by Adrian Freed, Yotam Mann (CNMAT)\n</code></pre>"},{"location":"exemplos/osc-bridge/#codigo-completo","title":"C\u00f3digo Completo","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/OSCConnection.h\"\n// Tools &gt; USB Mode \u2192 \"USB Host\"\n\nconst char* WIFI_SSID       = \"SeuSSID\";\nconst char* WIFI_PASSWORD   = \"SuaSenha\";\nIPAddress   REMOTE_IP       = IPAddress(192, 168, 1, 100);  // IP do computador (Max/MSP)\nconst int   LOCAL_OSC_PORT  = 8000;   // ESP32 escuta aqui\nconst int   REMOTE_OSC_PORT = 9000;   // Max/MSP escuta aqui\n\nOSCConnection oscMIDI;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    Serial.print(\"Conectando WiFi...\");\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.printf(\"\\nIP: %s\\n\", WiFi.localIP().toString().c_str());\n    Serial.printf(\"Enviando OSC para: %s:%d\\n\",\n        REMOTE_IP.toString().c_str(), REMOTE_OSC_PORT);\n    Serial.printf(\"Recebendo OSC em: :%d\\n\", LOCAL_OSC_PORT);\n\n    oscMIDI.begin(LOCAL_OSC_PORT, REMOTE_IP, REMOTE_OSC_PORT);\n    midiHandler.addTransport(&amp;oscMIDI);\n    midiHandler.begin();\n\n    Serial.println(\"Bridge OSC \u2194 MIDI pronta!\");\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    // Eventos MIDI (de USB ou OSC recebido do computador)\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"[MIDI] %s %s ch=%d vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.channel,\n            ev.velocity);\n\n        // USB \u2192 OSC \u00e9 autom\u00e1tico (oscMIDI.sendMidiMessage() \u00e9 chamado internamente)\n    }\n}\n</code></pre>"},{"location":"exemplos/osc-bridge/#enderecos-osc","title":"Endere\u00e7os OSC","text":"Dire\u00e7\u00e3o Endere\u00e7o OSC Argumentos ESP32 \u2192 Computador <code>/midi/noteon</code> <code>int channel, int note, int velocity</code> ESP32 \u2192 Computador <code>/midi/noteoff</code> <code>int channel, int note, int velocity</code> ESP32 \u2192 Computador <code>/midi/cc</code> <code>int channel, int controller, int value</code> ESP32 \u2192 Computador <code>/midi/pitchbend</code> <code>int channel, int bend</code> Computador \u2192 ESP32 <code>/midi/noteon</code> <code>int channel, int note, int velocity</code> Computador \u2192 ESP32 (todos os acima) \u2014"},{"location":"exemplos/osc-bridge/#patch-maxmsp","title":"Patch Max/MSP","text":"<p>Para receber MIDI do ESP32 no Max/MSP:</p> <pre><code>[udpreceive 9000]\n      |\n  [oscparse]\n      |\n  [route /midi/noteon /midi/noteoff /midi/cc]\n  |              |              |\n[unpack i i i] [unpack i i i] [unpack i i i]\n  |    |   |\n ch  note vel\n</code></pre> <p>Para enviar MIDI do Max/MSP para o ESP32:</p> <pre><code>[pack i i i]       \u2190 channel note velocity\n      |\n[oscformat /midi/noteon]\n      |\n[udpsend]\n[connect 192.168.1.X 8000]   \u2190 IP do ESP32\n</code></pre>"},{"location":"exemplos/osc-bridge/#patch-pure-data","title":"Patch Pure Data","text":"<p>Receber: <pre><code>[udpreceive 9000]\n      |\n  [import osc]\n  [oscparse]\n      |\n  [route /midi/noteon]\n</code></pre></p> <p>Enviar: <pre><code>[pack f f f]\n      |\n[oscformat /midi/noteon]\n      |\n[udpsend 192.168.1.X 8000]\n</code></pre></p>"},{"location":"exemplos/osc-bridge/#touchosc","title":"TouchOSC","text":"<p>Configure o TouchOSC (iOS/Android):</p> <ol> <li>Em Connections \u2192 OSC:</li> <li>Host: IP do ESP32</li> <li>Port (outgoing): 8000</li> <li>Port (incoming): 9000</li> <li>Crie bot\u00f5es com endere\u00e7os <code>/midi/noteon</code> e argumentos: canal, nota, velocidade</li> </ol>"},{"location":"exemplos/osc-bridge/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>OSC \u2192 \u2014 detalhes do transporte OSC</li> <li>RTP-MIDI \u2192 \u2014 alternativa para DAWs com AppleMIDI</li> <li>MIDI 2.0 \u2192 \u2014 protocolo UDP customizado com alta resolu\u00e7\u00e3o</li> </ul>"},{"location":"exemplos/rtp-midi-wifi/","title":"\ud83c\udf10 RTP-MIDI WiFi","text":"<p>O exemplo <code>RTP-MIDI-WiFi</code> implementa um sequenciador de etapas (step sequencer) que envia notas via Apple MIDI (RTP-MIDI) para macOS \u2014 aparecendo automaticamente em Audio MIDI Setup.</p>"},{"location":"exemplos/rtp-midi-wifi/#hardware-necessario","title":"Hardware Necess\u00e1rio","text":"Componente Detalhe Placa LilyGO T-Display-S3 (ou qualquer ESP32 com WiFi) Display ST7789 (embutido no T-Display-S3) Rede WiFi 2,4 GHz ou 5 GHz"},{"location":"exemplos/rtp-midi-wifi/#pre-requisito","title":"Pr\u00e9-requisito","text":"<p>Instalar a biblioteca AppleMIDI:</p> <pre><code>Manage Libraries \u2192 \"AppleMIDI\" \u2192 Arduino-AppleMIDI-Library by lathoub (v3.x)\n</code></pre>"},{"location":"exemplos/rtp-midi-wifi/#codigo-completo","title":"C\u00f3digo Completo","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/RTPMIDIConnection.h\"\n\n// \u2500\u2500\u2500 Configura\u00e7\u00e3o \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nconst char* WIFI_SSID     = \"SeuSSID\";\nconst char* WIFI_PASSWORD = \"SuaSenha\";\nconst char* MIDI_NAME     = \"Sequenciador ESP32\";\nconst int   BPM           = 120;\n\n// \u2500\u2500\u2500 Sequ\u00eancia \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nconst uint8_t NOTAS[]    = {60, 62, 64, 67, 69, 67, 64, 62};  // C D E G A G E D\nconst uint8_t VELS[]     = {100, 80, 90, 110, 95, 85, 75, 100};\nconst int     NUM_STEPS  = 8;\n\nRTPMIDIConnection rtpMIDI;\nint step = 0;\nunsigned long nextTick = 0;\nconst unsigned long NOTE_MS = 60000UL / BPM / 2;  // colcheia\n\nvoid setup() {\n    Serial.begin(115200);\n\n    // Conectar WiFi\n    Serial.printf(\"Conectando a %s...\", WIFI_SSID);\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.printf(\"\\nConectado! IP: %s\\n\", WiFi.localIP().toString().c_str());\n\n    // Iniciar RTP-MIDI\n    rtpMIDI.begin(MIDI_NAME);\n    midiHandler.addTransport(&amp;rtpMIDI);\n    midiHandler.begin();\n\n    Serial.printf(\"RTP-MIDI pronto \u2014 nome: '%s'\\n\", MIDI_NAME);\n    Serial.println(\"Abra 'Audio MIDI Setup' no Mac e conecte \u00e0 sess\u00e3o.\");\n    nextTick = millis();\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    // Receber MIDI do macOS (bidirecional)\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"[RTP IN] %s %s vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.velocity);\n    }\n\n    // Sequenciador \u2014 tocar pr\u00f3ximo step\n    unsigned long now = millis();\n    if (now &gt;= nextTick) {\n        // Desligar nota anterior\n        uint8_t prevNote = NOTAS[(step + NUM_STEPS - 1) % NUM_STEPS];\n        midiHandler.sendNoteOff(1, prevNote, 0);\n\n        // Ligar pr\u00f3xima nota\n        midiHandler.sendNoteOn(1, NOTAS[step], VELS[step]);\n        Serial.printf(\"[SEQ] Step %d: %d (vel=%d)\\n\",\n            step, NOTAS[step], VELS[step]);\n\n        step = (step + 1) % NUM_STEPS;\n        nextTick = now + NOTE_MS;\n    }\n}\n</code></pre>"},{"location":"exemplos/rtp-midi-wifi/#configuracao-no-macos","title":"Configura\u00e7\u00e3o no macOS","text":"<pre><code>sequenceDiagram\n    participant ESP32 as ESP32 (Sequenciador)\n    participant BONJOUR as mDNS / Bonjour\n    participant MAC as macOS (Audio MIDI Setup)\n    participant LOGIC as Logic Pro\n\n    ESP32-&gt;&gt;BONJOUR: Anuncia \"Sequenciador ESP32\"\n    MAC-&gt;&gt;BONJOUR: Descobre sess\u00f5es na rede\n    BONJOUR--&gt;&gt;MAC: \"Sequenciador ESP32\" dispon\u00edvel\n    MAC-&gt;&gt;ESP32: Connect\n    MAC-&gt;&gt;LOGIC: Porta \"Sequenciador ESP32\" dispon\u00edvel\n\n    loop Sequenciador rodando\n        ESP32-&gt;&gt;MAC: NoteOn / NoteOff via RTP-MIDI\n        MAC-&gt;&gt;LOGIC: MIDI events na faixa\n    end</code></pre>"},{"location":"exemplos/rtp-midi-wifi/#passo-a-passo","title":"Passo a passo","text":"<ol> <li>Abra Audio MIDI Setup \u2192 Window \u2192 Show MIDI Studio</li> <li>Clique no \u00edcone Network (globo)</li> <li>No painel \"Directory\", clique em + e selecione \"Sequenciador ESP32\"</li> <li>Clique em Connect</li> <li>Abra Logic Pro / GarageBand \u2192 a porta aparece automaticamente</li> </ol>"},{"location":"exemplos/rtp-midi-wifi/#galeria","title":"Galeria","text":"Audio MIDI Setup \u2014 sess\u00e3o ativa Sequenciador conectado ao macOS"},{"location":"exemplos/rtp-midi-wifi/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>RTP-MIDI \u2192 \u2014 detalhes do transporte</li> <li>Ethernet MIDI \u2192 \u2014 vers\u00e3o cabeada com menor lat\u00eancia</li> <li>OSC Bridge \u2192 \u2014 alternativa para Max/MSP</li> </ul>"},{"location":"exemplos/t-display-s3/","title":"\ud83d\udda5\ufe0f T-Display-S3 Piano","text":"<p>O exemplo <code>T-Display-S3-Piano</code> transforma a LilyGO T-Display-S3 em um visualizador de piano ao vivo com rolagem de 25 teclas, detec\u00e7\u00e3o de acordes e exibi\u00e7\u00e3o de informa\u00e7\u00f5es MIDI em tempo real.</p>"},{"location":"exemplos/t-display-s3/#hardware-necessario","title":"Hardware Necess\u00e1rio","text":"Componente Modelo Placa LilyGO T-Display-S3 Display ST7789 1.9\" 170\u00d7320 (embutido) Teclado Qualquer USB MIDI class-compliant Cabo USB-OTG (micro para USB-A f\u00eamea)"},{"location":"exemplos/t-display-s3/#o-que-o-exemplo-faz","title":"O Que o Exemplo Faz","text":"<ul> <li>Piano roll de 25 teclas: mostra as teclas C4 a C6 como um piano horizontal</li> <li>Rolagem autom\u00e1tica: a janela de 25 teclas rola para mostrar as notas ativas</li> <li>Notas ativas: teclas pressionadas aparecem em destaque</li> <li>Log de eventos: \u00faltimos 8 eventos na tela (nota, canal, velocidade, timestamp)</li> <li>Informa\u00e7\u00f5es USB: status da conex\u00e3o USB Host</li> </ul>"},{"location":"exemplos/t-display-s3/#configuracao-arduino-ide","title":"Configura\u00e7\u00e3o Arduino IDE","text":"<pre><code>Board: \"LilyGo T-Display-S3\" (ou \"ESP32S3 Dev Module\")\nTools &gt; USB Mode \u2192 \"USB Host\"\nTools &gt; PSRAM \u2192 \"OPI PSRAM\"\nUpload Speed: 921600\n</code></pre>"},{"location":"exemplos/t-display-s3/#estrutura-do-exemplo","title":"Estrutura do Exemplo","text":"<pre><code>examples/T-Display-S3-Piano/\n\u251c\u2500\u2500 T-Display-S3-Piano.ino    \u2190 Sketch principal\n\u251c\u2500\u2500 mapping.h                  \u2190 Pinos de hardware\n\u251c\u2500\u2500 ST7789_Handler.h           \u2190 Interface do display\n\u2514\u2500\u2500 ST7789_Handler.cpp         \u2190 Implementa\u00e7\u00e3o do display\n</code></pre>"},{"location":"exemplos/t-display-s3/#mappingh-pinos","title":"mapping.h \u2014 Pinos","text":"<pre><code>// T-Display-S3 pinout\n#define TFT_CS    6\n#define TFT_RST   5\n#define TFT_DC    7\n#define TFT_MOSI  11\n#define TFT_SCLK  12\n#define TFT_BL    38   // Backlight\n</code></pre>"},{"location":"exemplos/t-display-s3/#sketch-principal-simplificado","title":"Sketch Principal (simplificado)","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/GingoAdapter.h\"   // Detec\u00e7\u00e3o de acordes\n#include \"ST7789_Handler.h\"\n#include \"mapping.h\"\n// Tools &gt; USB Mode \u2192 \"USB Host\"\n\nST7789_Handler display;\n\nvoid setup() {\n    Serial.begin(115200);\n    display.begin();\n    display.clear();\n\n    MIDIHandlerConfig cfg;\n    cfg.maxEvents = 20;\n    cfg.chordTimeWindow = 50;\n    midiHandler.begin(cfg);\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    // Atualizar display quando notas mudarem\n    bool active[128] = {false};\n    midiHandler.fillActiveNotes(active);\n    display.updatePianoRoll(active);\n\n    // Mostrar nome do acorde\n    char chord[16] = \"\";\n    if (midiHandler.getActiveNotesCount() &gt; 0) {\n        GingoAdapter::identifyLastChord(midiHandler, chord, sizeof(chord));\n    }\n    display.showChord(chord);\n\n    // Log de eventos\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        display.addEvent(ev.noteOctave.c_str(), ev.channel, ev.velocity);\n    }\n\n    display.render();\n}\n</code></pre>"},{"location":"exemplos/t-display-s3/#galeria","title":"Galeria","text":"Piano roll de 25 teclas com notas ativas Detec\u00e7\u00e3o de acordes em tempo real"},{"location":"exemplos/t-display-s3/#outros-exemplos-t-display-s3","title":"Outros Exemplos T-Display-S3","text":"Exemplo Transporte O que mostra <code>T-Display-S3</code> USB Host Notas ativas + log <code>T-Display-S3-Queue</code> USB Host Fila de eventos debug <code>T-Display-S3-Piano</code> USB Host Piano roll 25 teclas <code>T-Display-S3-Piano-Debug</code> USB Host Piano + debug estendido <code>T-Display-S3-Gingoduino</code> USB + BLE Acordes (Gingoduino) <code>T-Display-S3-BLE-Sender</code> BLE Sequenciador BLE <code>T-Display-S3-BLE-Receiver</code> BLE Receptor BLE <code>T-Display-S3-OSC</code> OSC + WiFi Bridge OSC <code>T-Display-S3-USB-Device</code> BLE + USB Device Bridge duplo <code>T-Display-S3-MIDI2-UDP</code> MIDI 2.0 UDP Vel. 16-bit <code>T-Display-S3-ESP-NOW-Jam</code> ESP-NOW Jam colaborativo"},{"location":"exemplos/t-display-s3/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>GingoAdapter \u2192 \u2014 detec\u00e7\u00e3o de acordes</li> <li>USB Host \u2192 \u2014 detalhes do transporte USB</li> <li>UART B\u00e1sico \u2192 \u2014 exemplo mais simples</li> </ul>"},{"location":"exemplos/uart-basico/","title":"\ud83c\udfb9 UART MIDI B\u00e1sico","text":"<p>O exemplo <code>UART-MIDI-Basic</code> \u00e9 o sketch mais simples da biblioteca \u2014 MIDI serial via DIN-5 impresso no Serial Monitor. Ideal para testar a instala\u00e7\u00e3o sem hardware USB-OTG.</p>"},{"location":"exemplos/uart-basico/#hardware-necessario","title":"Hardware Necess\u00e1rio","text":"Componente Detalhe Placa Qualquer ESP32 MIDI IN Optoacoplador (6N138, PC-900V) + DIN-5 MIDI OUT 2\u00d7 resistores 220\u03a9 + DIN-5 (opcional)"},{"location":"exemplos/uart-basico/#circuito-midi-in","title":"Circuito MIDI IN","text":"<pre><code>DIN-5 pino 5 \u2500\u2500\u2500 220\u03a9 \u2500\u2500\u2500\u25ba 6N138 (pino 2, LED +)\nDIN-5 pino 4 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba 6N138 (pino 3, LED -)\nDIN-5 pino 2 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba GND\n\n6N138 pino 8 (VCC) \u2500\u2500\u2500\u25ba 3.3V\n6N138 pino 6 (Vout) \u2500\u2500\u25ba ESP32 GPIO RX (pull-up interno)\n6N138 pino 4 (GND) \u2500\u2500\u2500\u25ba GND\n</code></pre> <p>Isola\u00e7\u00e3o obrigat\u00f3ria</p> <p>Conectar DIN-5 diretamente ao GPIO sem optoacoplador pode danificar o ESP32. Sempre use isola\u00e7\u00e3o \u00f3ptica para MIDI IN.</p>"},{"location":"exemplos/uart-basico/#codigo-completo","title":"C\u00f3digo Completo","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/UARTConnection.h\"\n\n// Pinos MIDI\n#define MIDI_RX_PIN 16   // Conectado ao optoacoplador\n#define MIDI_TX_PIN 17   // Conectado ao DIN-5 MIDI OUT (via 220\u03a9)\n\nUARTConnection uartMIDI;\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"UART MIDI Basic \u2014 ESP32_Host_MIDI\");\n    Serial.println(\"-----------------------------------\");\n\n    // Iniciar UART MIDI (31250 baud)\n    uartMIDI.begin(Serial1, MIDI_RX_PIN, MIDI_TX_PIN);\n\n    // Registrar e iniciar o handler\n    midiHandler.addTransport(&amp;uartMIDI);\n    midiHandler.begin();\n\n    Serial.println(\"Pronto! Aguardando MIDI via DIN-5...\");\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        // Imprimir evento formatado\n        if (ev.status == \"NoteOn\" &amp;&amp; ev.velocity &gt; 0) {\n            Serial.printf(\"[NoteOn]  %-5s  canal=%d  vel=%3d  t=%lu ms\\n\",\n                ev.noteOctave.c_str(), ev.channel, ev.velocity, ev.timestamp);\n\n            // Teste de NoteOff autom\u00e1tico ap\u00f3s 100ms (TX)\n            delay(100);\n            midiHandler.sendNoteOff(ev.channel, ev.note, 0);\n\n        } else if (ev.status == \"NoteOff\") {\n            Serial.printf(\"[NoteOff] %-5s  canal=%d\\n\",\n                ev.noteOctave.c_str(), ev.channel);\n\n        } else if (ev.status == \"ControlChange\") {\n            Serial.printf(\"[CC]      #%-3d = %3d  canal=%d\\n\",\n                ev.note, ev.velocity, ev.channel);\n\n        } else if (ev.status == \"PitchBend\") {\n            Serial.printf(\"[PitchBend] %d  canal=%d\\n\",\n                ev.pitchBend, ev.channel);\n        }\n    }\n}\n</code></pre>"},{"location":"exemplos/uart-basico/#saida-do-serial-monitor","title":"Sa\u00edda do Serial Monitor","text":"<p>Ao tocar um acorde de D\u00f3 maior em um teclado MIDI:</p> <pre><code>UART MIDI Basic \u2014 ESP32_Host_MIDI\n-----------------------------------\nPronto! Aguardando MIDI via DIN-5...\n[NoteOn]  C4    canal=1  vel=100  t=1234 ms\n[NoteOn]  E4    canal=1  vel= 95  t=1235 ms\n[NoteOn]  G4    canal=1  vel=110  t=1236 ms\n[NoteOff] C4    canal=1\n[NoteOff] E4    canal=1\n[NoteOff] G4    canal=1\n[CC]      #7  = 127  canal=1\n</code></pre>"},{"location":"exemplos/uart-basico/#teste-de-tx-midi-out","title":"Teste de TX (MIDI OUT)","text":"<p>Para testar o MIDI OUT, envie notas programaticamente:</p> <pre><code>// Adicionar ao loop() para tocar uma escala de D\u00f3\nstatic unsigned long lastNote = 0;\nstatic int noteIdx = 0;\nconst int ESCALA[] = {60, 62, 64, 65, 67, 69, 71, 72};  // C-D-E-F-G-A-B-C\n\nif (millis() - lastNote &gt; 500) {\n    // Desliga nota anterior\n    if (noteIdx &gt; 0) {\n        midiHandler.sendNoteOff(1, ESCALA[(noteIdx - 1) % 8], 0);\n    }\n    // Liga pr\u00f3xima nota\n    midiHandler.sendNoteOn(1, ESCALA[noteIdx % 8], 100);\n    noteIdx++;\n    lastNote = millis();\n}\n</code></pre>"},{"location":"exemplos/uart-basico/#pinos-por-placa","title":"Pinos por Placa","text":"Placa RX (GPIO) TX (GPIO) ESP32 DevKit 16 17 ESP32-S3 DevKit 18 17 LilyGO T-Display-S3 18 17 ESP32-C3 4 5 ESP32-P4 (UART1) 16 17"},{"location":"exemplos/uart-basico/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>UART / DIN-5 \u2192 \u2014 detalhes do transporte e circuito</li> <li>RTP-MIDI WiFi \u2192 \u2014 combinar UART com Apple MIDI</li> <li>T-Display-S3 \u2192 \u2014 adicionar display ao projeto</li> </ul>"},{"location":"funcionalidades/deteccao-acordes/","title":"\ud83c\udfbc Detec\u00e7\u00e3o de Acordes","text":"<p>O <code>MIDIHandler</code> agrupa automaticamente notas simult\u00e2neas usando o campo <code>chordIndex</code>. Notas com o mesmo <code>chordIndex</code> foram pressionadas \"ao mesmo tempo\" (dentro da janela configurada).</p>"},{"location":"funcionalidades/deteccao-acordes/#como-funciona","title":"Como Funciona","text":"<p>Cada evento MIDI recebe um <code>chordIndex</code>. Notas que chegam pr\u00f3ximas no tempo compartilham o mesmo \u00edndice:</p> <pre><code>Notas pressionadas:   C4  E4  G4  (acorde D\u00f3 maior)\nchordIndex:            1   1   1   \u2190 mesmo \u00edndice\n                                   \u2190 B4 pressionado depois\nB4 pressionado:       B4\nchordIndex:            2           \u2190 novo \u00edndice\n</code></pre>"},{"location":"funcionalidades/deteccao-acordes/#configuracao","title":"Configura\u00e7\u00e3o","text":""},{"location":"funcionalidades/deteccao-acordes/#chordtimewindow","title":"chordTimeWindow","text":"<p>Controla a janela de tempo (ms) para agrupar notas:</p> <pre><code>MIDIHandlerConfig cfg;\ncfg.chordTimeWindow = 0;   // 0 ms (padr\u00e3o): novo acorde s\u00f3 quando TODAS as notas s\u00e3o soltas\ncfg.chordTimeWindow = 50;  // 50 ms: janela de tempo (ideal para teclados f\u00edsicos)\nmidiHandler.begin(cfg);\n</code></pre> <pre><code>sequenceDiagram\n    participant KEY as \ud83c\udfb9 Teclado\n    participant HANDLER as MIDIHandler\n\n    Note over KEY,HANDLER: chordTimeWindow = 50ms\n\n    KEY-&gt;&gt;HANDLER: NoteOn C4  (t = 0ms)\n    Note right of HANDLER: chordIndex = 1\n    KEY-&gt;&gt;HANDLER: NoteOn E4  (t = 20ms)\n    Note right of HANDLER: chordIndex = 1 \u2705 dentro da janela\n    KEY-&gt;&gt;HANDLER: NoteOn G4  (t = 45ms)\n    Note right of HANDLER: chordIndex = 1 \u2705 dentro da janela\n    KEY-&gt;&gt;HANDLER: NoteOn B4  (t = 120ms)\n    Note right of HANDLER: chordIndex = 2 \u274c nova janela (&gt;50ms)</code></pre>"},{"location":"funcionalidades/deteccao-acordes/#api-de-acordes","title":"API de Acordes","text":""},{"location":"funcionalidades/deteccao-acordes/#lastchord-indice-do-ultimo-acorde","title":"lastChord() \u2014 \u00cdndice do \u00daltimo Acorde","text":"<p>Retorna o <code>chordIndex</code> mais recente na fila:</p> <pre><code>const auto&amp; queue = midiHandler.getQueue();\nint idx = midiHandler.lastChord(queue);  // -1 se a fila estiver vazia\n</code></pre>"},{"location":"funcionalidades/deteccao-acordes/#getchord-notas-do-acorde","title":"getChord() \u2014 Notas do Acorde","text":"<p>Retorna os valores de um campo espec\u00edfico para todas as notas de um acorde:</p> <pre><code>const auto&amp; queue = midiHandler.getQueue();\nint idx = midiHandler.lastChord(queue);\n\n// Lista de nomes de notas com oitava\nstd::vector&lt;std::string&gt; notas = midiHandler.getChord(idx, queue, {\"noteOctave\"});\n// Exemplo: [\"C4\", \"E4\", \"G4\"]\n\n// Lista de velocidades\nstd::vector&lt;std::string&gt; vels = midiHandler.getChord(idx, queue, {\"velocity\"});\n// Exemplo: [\"100\", \"95\", \"110\"]\n\n// M\u00faltiplos campos com labels\nstd::vector&lt;std::string&gt; info = midiHandler.getChord(\n    idx, queue, {\"noteOctave\", \"velocity\"}, /*includeLabels=*/true);\n// Exemplo: [\"noteOctave:C4\", \"noteOctave:E4\", \"velocity:100\", \"velocity:95\"]\n</code></pre>"},{"location":"funcionalidades/deteccao-acordes/#getanswer-resposta-rapida-do-ultimo-acorde","title":"getAnswer() \u2014 Resposta R\u00e1pida do \u00daltimo Acorde","text":"<p>Atalho para o acorde mais recente, sem precisar chamar <code>lastChord()</code>:</p> <pre><code>// Nome das notas do \u00faltimo acorde\nstd::vector&lt;std::string&gt; resp = midiHandler.getAnswer(\"noteName\");\n// Exemplo: [\"C\", \"E\", \"G\"]\n\n// M\u00faltiplos campos\nstd::vector&lt;std::string&gt; multi = midiHandler.getAnswer({\"noteName\", \"velocity\"});\n</code></pre>"},{"location":"funcionalidades/deteccao-acordes/#exemplo-completo","title":"Exemplo Completo","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n// Tools &gt; USB Mode \u2192 \"USB Host\"\n\nvoid setup() {\n    Serial.begin(115200);\n\n    MIDIHandlerConfig cfg;\n    cfg.chordTimeWindow = 50;  // agrupa notas dentro de 50ms\n    midiHandler.begin(cfg);\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    const auto&amp; queue = midiHandler.getQueue();\n    if (queue.empty()) return;\n\n    // Verificar se h\u00e1 novas notas\n    int lastIdx = midiHandler.lastChord(queue);\n    if (lastIdx &lt; 0) return;\n\n    // Pegar notas do acorde mais recente\n    auto notas = midiHandler.getChord(lastIdx, queue, {\"noteOctave\"});\n\n    if (!notas.empty()) {\n        Serial.print(\"Acorde [\" + String(lastIdx) + \"]: \");\n        for (const auto&amp; n : notas) {\n            Serial.print(n.c_str());\n            Serial.print(\" \");\n        }\n        Serial.println();\n    }\n}\n</code></pre> <p>Sa\u00edda t\u00edpica ao tocar D\u00f3 maior (C-E-G):</p> <pre><code>Acorde [1]: C4 E4 G4\nAcorde [2]: C4 F4 A4    \u2190 F\u00e1 maior\nAcorde [3]: G3 B3 D4    \u2190 Sol maior\n</code></pre>"},{"location":"funcionalidades/deteccao-acordes/#detectar-mudanca-de-acorde","title":"Detectar Mudan\u00e7a de Acorde","text":"<pre><code>void loop() {\n    midiHandler.task();\n\n    const auto&amp; queue = midiHandler.getQueue();\n    static int ultimoAcorde = -1;\n\n    int idx = midiHandler.lastChord(queue);\n    if (idx != ultimoAcorde &amp;&amp; idx &gt;= 0) {\n        ultimoAcorde = idx;\n\n        auto notas = midiHandler.getChord(idx, queue, {\"noteOctave\"});\n        if (!notas.empty()) {\n            Serial.print(\"Novo acorde: \");\n            for (const auto&amp; n : notas) Serial.print(String(n.c_str()) + \" \");\n            Serial.println();\n        }\n    }\n}\n</code></pre>"},{"location":"funcionalidades/deteccao-acordes/#integracao-com-gingoduino","title":"Integra\u00e7\u00e3o com Gingoduino","text":"<p>Para identificar o nome do acorde (\"Cmaj7\", \"Dm7\u266d5\"), use o GingoAdapter:</p> <pre><code>#include \"src/GingoAdapter.h\"  // requer Gingoduino \u2265 v0.2.2\n\nchar chordName[16];\nif (GingoAdapter::identifyLastChord(midiHandler, chordName, sizeof(chordName))) {\n    Serial.printf(\"Acorde: %s\\n\", chordName);\n    // Exemplo: \"Cmaj7\", \"Dm\", \"G7sus4\"\n}\n</code></pre>"},{"location":"funcionalidades/deteccao-acordes/#chordindex-no-loop-de-eventos","title":"chordIndex no Loop de Eventos","text":"<p>O <code>chordIndex</code> \u00e9 parte de cada <code>MIDIEventData</code>. Voc\u00ea pode usar diretamente na itera\u00e7\u00e3o:</p> <pre><code>for (const auto&amp; ev : midiHandler.getQueue()) {\n    if (ev.status == \"NoteOn\") {\n        Serial.printf(\"Nota %s  acorde #%d  vel=%d\\n\",\n            ev.noteOctave.c_str(),\n            ev.chordIndex,\n            ev.velocity);\n    }\n}\n</code></pre>"},{"location":"funcionalidades/deteccao-acordes/#bug-classico-analisar-apenas-uma-nota","title":"Bug Cl\u00e1ssico: Analisar Apenas uma Nota","text":"<p>Aten\u00e7\u00e3o ao analisar acordes em tempo real</p> <p>Analise o acorde sempre que o noteCount mudar, n\u00e3o apenas na chegada de um evento novo. Se voc\u00ea verificar apenas em <code>chordIndex != lastIdx</code>, a an\u00e1lise acontece na primeira nota e as seguintes s\u00e3o ignoradas.</p> <p>Correto: <pre><code>size_t count = midiHandler.getActiveNotesCount();\nif (count != lastCount) {\n    lastCount = count;\n    // re-analisar acorde\n}\n</code></pre></p>"},{"location":"funcionalidades/deteccao-acordes/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Notas Ativas \u2192 \u2014 quais notas est\u00e3o pressionadas agora</li> <li>GingoAdapter \u2192 \u2014 identificar nome do acorde</li> <li>Configura\u00e7\u00e3o \u2192 \u2014 ajustar <code>chordTimeWindow</code></li> </ul>"},{"location":"funcionalidades/gingo-adapter/","title":"\ud83c\udfb5 GingoAdapter","text":"<p><code>GingoAdapter.h</code> \u00e9 uma bridge entre o <code>MIDIHandler</code> e a biblioteca Gingoduino \u2014 a biblioteca de teoria musical para sistemas embarcados. Com ela, voc\u00ea identifica nomes de acordes (\"Cmaj7\", \"Dm7\u266d5\"), campos harm\u00f4nicos e progress\u00f5es \u2014 tudo on-device, sem rede.</p>"},{"location":"funcionalidades/gingo-adapter/#pre-requisito","title":"Pr\u00e9-requisito","text":"<p>Instale o Gingoduino v0.2.2 ou superior:</p> <pre><code>Arduino IDE \u2192 Manage Libraries \u2192 \"gingoduino\" \u2192 Instalar\n</code></pre>"},{"location":"funcionalidades/gingo-adapter/#o-que-e-o-gingoduino","title":"O Que \u00e9 o Gingoduino?","text":"<p>O Gingoduino analisa conjuntos de notas MIDI e retorna:</p> <ul> <li>Nome do acorde: \"Cmaj7\", \"Dm\", \"G7sus4\", \"F#dim7\"...</li> <li>Nota raiz: \"C\", \"F#\", \"Bb\"...</li> <li>Campo harm\u00f4nico: em que tonalidade o acorde se encaixa</li> <li>Progress\u00e3o de acordes: identifica padr\u00f5es (II-V-I, etc.)</li> </ul> <p>Tudo roda no dispositivo, em tempo real, sem nuvem ou rede.</p>"},{"location":"funcionalidades/gingo-adapter/#fluxo-de-integracao","title":"Fluxo de Integra\u00e7\u00e3o","text":"<pre><code>flowchart LR\n    USB[\"\ud83c\udfb9 Teclado USB\\nou BLE MIDI\"]\n    HANDLER[\"MIDIHandler\\nfila de eventos\\nnotas ativas\"]\n    ADAPTER[\"GingoAdapter\\nconverte MIDI \u2192 Gingo\"]\n    GINGO[\"Gingoduino\\nidentifyChord()\\ngetField()\"]\n    OUT[\"\ud83c\udfbc Nome do acorde\\n'Cmaj7', 'Dm7\u266d5'\"]\n\n    USB --&gt; HANDLER\n    HANDLER --&gt; ADAPTER\n    ADAPTER --&gt; GINGO\n    GINGO --&gt; OUT\n\n    style HANDLER fill:#3F51B5,color:#fff\n    style ADAPTER fill:#37474F,color:#fff\n    style GINGO fill:#1B5E20,color:#fff</code></pre>"},{"location":"funcionalidades/gingo-adapter/#uso-basico","title":"Uso B\u00e1sico","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/GingoAdapter.h\"  // requer Gingoduino \u2265 v0.2.2\n// Tools &gt; USB Mode \u2192 \"USB Host\"\n\nvoid setup() {\n    Serial.begin(115200);\n    midiHandler.begin();\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    // Verificar quando as notas ativas mudarem\n    static size_t lastCount = 0;\n    size_t count = midiHandler.getActiveNotesCount();\n\n    if (count != lastCount) {\n        lastCount = count;\n\n        if (count &gt; 0) {\n            char chordName[16] = \"\";\n\n            // Identificar nome do acorde\n            if (GingoAdapter::identifyLastChord(midiHandler, chordName, sizeof(chordName))) {\n                Serial.printf(\"Acorde: %s  (%d notas)\\n\", chordName, (int)count);\n            } else {\n                Serial.printf(\"Notas: %s\\n\", midiHandler.getActiveNotes().c_str());\n            }\n        } else {\n            Serial.println(\"[ sem notas ]\");\n        }\n    }\n}\n</code></pre>"},{"location":"funcionalidades/gingo-adapter/#api-gingoadapter","title":"API GingoAdapter","text":""},{"location":"funcionalidades/gingo-adapter/#identifylastchord-nome-do-acorde","title":"identifyLastChord() \u2014 Nome do acorde","text":"<pre><code>char nome[16];\nbool encontrado = GingoAdapter::identifyLastChord(\n    midiHandler,    // refer\u00eancia ao MIDIHandler\n    nome,           // buffer de sa\u00edda\n    sizeof(nome)    // tamanho do buffer\n);\n\nif (encontrado) {\n    // nome = \"Cmaj7\", \"Dm\", \"G7sus4\", \"F#dim\", etc.\n    Serial.printf(\"Acorde: %s\\n\", nome);\n} else {\n    // Notas n\u00e3o formam um acorde reconhecido\n}\n</code></pre>"},{"location":"funcionalidades/gingo-adapter/#miditogingonotes-converter-midi-para-gingonote","title":"midiToGingoNotes() \u2014 Converter MIDI para GingoNote","text":"<pre><code>uint8_t midiNotes[] = {60, 64, 67};  // C, E, G\nGingoNote gingoNotas[7];\nuint8_t count = GingoAdapter::midiToGingoNotes(\n    midiNotes, 3, gingoNotas\n);\n// gingoNotas[0] = D\u00f3, gingoNotas[1] = Mi, gingoNotas[2] = Sol\n</code></pre>"},{"location":"funcionalidades/gingo-adapter/#deducefieldfromqueue-campo-harmonico-tier-2","title":"deduceFieldFromQueue() \u2014 Campo Harm\u00f4nico (Tier 2)","text":"<pre><code>#if defined(GINGODUINO_HAS_FIELD)\nFieldMatch campos[8];\nuint8_t count = GingoAdapter::deduceFieldFromQueue(\n    midiHandler, campos, 8\n);\n\nfor (uint8_t i = 0; i &lt; count; i++) {\n    Serial.printf(\"Campo: %s (score: %d)\\n\",\n        campos[i].name, campos[i].score);\n}\n#endif\n</code></pre>"},{"location":"funcionalidades/gingo-adapter/#identifyprogression-progressao-tier-3","title":"identifyProgression() \u2014 Progress\u00e3o (Tier 3)","text":"<pre><code>#if defined(GINGODUINO_HAS_PROGRESSION)\nconst char* branches[] = {\"IIm\", \"V7\", \"I\"};\nProgressionMatch resultado;\n\nif (GingoAdapter::identifyProgression(\"C\", SCALE_MAJOR, branches, 3, &amp;resultado)) {\n    Serial.printf(\"Progress\u00e3o encontrada: %s\\n\", resultado.name);\n}\n#endif\n</code></pre>"},{"location":"funcionalidades/gingo-adapter/#exemplo-com-display-t-display-s3","title":"Exemplo com Display (T-Display-S3)","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/GingoAdapter.h\"\n\nvoid setup() {\n    midiHandler.begin();\n    // inicializar display aqui\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    static size_t lastCount = 0;\n    size_t count = midiHandler.getActiveNotesCount();\n\n    if (count != lastCount) {\n        lastCount = count;\n\n        char chord[16] = \"\";\n        if (count &gt; 0) {\n            GingoAdapter::identifyLastChord(midiHandler, chord, sizeof(chord));\n        }\n\n        // Mostrar no display\n        // display.showChord(chord);\n        // display.showNotes(midiHandler.getActiveNotes().c_str());\n    }\n}\n</code></pre> T-Display-S3-Gingoduino: nome do acorde, nota raiz e teclas ativas em tempo real"},{"location":"funcionalidades/gingo-adapter/#tiers-do-gingoduino","title":"Tiers do Gingoduino","text":"Tier Feature Macro 0 Notas, intervalos sempre dispon\u00edvel 1 Identifica\u00e7\u00e3o de acordes <code>GINGODUINO_HAS_CHORD</code> 2 Campo harm\u00f4nico <code>GINGODUINO_HAS_FIELD</code> 3 Progress\u00f5es <code>GINGODUINO_HAS_PROGRESSION</code>"},{"location":"funcionalidades/gingo-adapter/#links-do-ecossistema","title":"Links do Ecossistema","text":"<ul> <li>Gingoduino no GitHub \u2014 biblioteca de teoria musical para ESP32</li> <li>Gingo (Python) \u2014 vers\u00e3o desktop do Gingoduino</li> </ul>"},{"location":"funcionalidades/gingo-adapter/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Detec\u00e7\u00e3o de Acordes \u2192 \u2014 usar chordIndex sem Gingoduino</li> <li>Exemplos T-Display-S3 \u2192 \u2014 piano roll + acordes no display</li> </ul>"},{"location":"funcionalidades/historico-psram/","title":"\ud83d\udcbe Hist\u00f3rico em PSRAM","text":"<p>O <code>MIDIHandler</code> pode manter um buffer circular de eventos que persiste al\u00e9m do limite da fila principal (<code>maxEvents</code>). Quando PSRAM est\u00e1 dispon\u00edvel, o buffer \u00e9 alocado l\u00e1 \u2014 permitindo hist\u00f3ricos de centenas ou milhares de eventos sem consumir heap.</p>"},{"location":"funcionalidades/historico-psram/#quando-usar","title":"Quando Usar","text":"<ul> <li>An\u00e1lise offline: processar uma sess\u00e3o de improvisa\u00e7\u00e3o depois que terminou</li> <li>Visualiza\u00e7\u00e3o de hist\u00f3rico: scrollar por eventos passados no display</li> <li>Debug: inspecionar o que aconteceu nos \u00faltimos N eventos</li> <li>Machine learning: coletar dados de performance para an\u00e1lise</li> </ul>"},{"location":"funcionalidades/historico-psram/#configuracao","title":"Configura\u00e7\u00e3o","text":""},{"location":"funcionalidades/historico-psram/#via-midihandlerconfig","title":"Via MIDIHandlerConfig","text":"<pre><code>MIDIHandlerConfig cfg;\ncfg.historyCapacity = 500;  // guardar os \u00faltimos 500 eventos\nmidiHandler.begin(cfg);\n</code></pre>"},{"location":"funcionalidades/historico-psram/#via-enablehistory-apos-begin","title":"Via enableHistory() \u2014 ap\u00f3s begin()","text":"<pre><code>midiHandler.begin();\nmidiHandler.enableHistory(500);  // pode ser chamado a qualquer momento\n</code></pre>"},{"location":"funcionalidades/historico-psram/#como-funciona","title":"Como Funciona","text":"<pre><code>flowchart TD\n    EV[\"Novo Evento MIDI\\n(MIDIEventData)\"]\n    QUEUE[\"Fila Principal\\n(maxEvents = 20)\\ngetQueue()\"]\n    HISTORY[\"Buffer Circular\\n(historyCapacity = 500)\\nPSRAM quando dispon\u00edvel\"]\n\n    EV --&gt; QUEUE\n    EV --&gt; HISTORY\n\n    subgraph PSRAM_CHECK[\"Aloca\u00e7\u00e3o\"]\n        CHECK{{\"ESP32_HOST_MIDI_HAS_PSRAM?\"}}\n        PSRAMOK[\"heap_caps_malloc\\nMALLOC_CAP_SPIRAM\"]\n        HEAPOK[\"malloc()\\n(heap normal)\"]\n    end\n\n    HISTORY --&gt; CHECK\n    CHECK --&gt;|\"\u2705 Sim\"| PSRAMOK\n    CHECK --&gt;|\"\u274c N\u00e3o\"| HEAPOK\n\n    style PSRAM_CHECK fill:#37474F,color:#fff\n    style PSRAMOK fill:#1B5E20,color:#fff\n    style HEAPOK fill:#BF360C,color:#fff</code></pre>"},{"location":"funcionalidades/historico-psram/#psram-no-esp32-s3","title":"PSRAM no ESP32-S3","text":"<p>Para ativar PSRAM no Arduino IDE:</p> <pre><code>Tools \u2192 PSRAM \u2192 \"OPI PSRAM\" (para ESP32-S3 com PSRAM OPI)\n        ou\nTools \u2192 PSRAM \u2192 \"Quad PSRAM\" (para ESP32-S3 com PSRAM SIP)\n</code></pre> <p>Verificar se est\u00e1 ativo:</p> <pre><code>Serial.printf(\"PSRAM: %u bytes\\n\", ESP.getPsramSize());\nSerial.printf(\"PSRAM livre: %u bytes\\n\", ESP.getFreePsram());\n</code></pre> <p>Verificar disponibilidade</p> <p>A macro <code>ESP32_HOST_MIDI_HAS_PSRAM</code> \u00e9 definida automaticamente em tempo de compila\u00e7\u00e3o se o sdkconfig tiver <code>CONFIG_SPIRAM</code> ou <code>CONFIG_SPIRAM_SUPPORT</code>.</p>"},{"location":"funcionalidades/historico-psram/#tamanho-do-historico","title":"Tamanho do Hist\u00f3rico","text":"<p>Cada <code>MIDIEventData</code> ocupa aproximadamente 80\u2013120 bytes (depende do tamanho das strings STL).</p> Capacidade Mem\u00f3ria aprox. Adequado para 100 ~10 KB Heap (sem PSRAM) 500 ~50 KB Heap ou PSRAM 1000 ~100 KB PSRAM recomendado 5000 ~500 KB PSRAM obrigat\u00f3rio"},{"location":"funcionalidades/historico-psram/#acessar-o-historico","title":"Acessar o Hist\u00f3rico","text":"<pre><code>// Habilitar hist\u00f3rico de 500 eventos\nmidiHandler.enableHistory(500);\n\n// A fila principal (getQueue()) continua limitada por maxEvents\n// O hist\u00f3rico \u00e9 acessado internamente \u2014 n\u00e3o h\u00e1 API direta de leitura\n\n// Por ora, use a fila + seu pr\u00f3prio buffer para acesso ao hist\u00f3rico:\nstd::vector&lt;MIDIEventData&gt; meuHistorico;\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        meuHistorico.push_back(ev);\n\n        // Limitar ao tamanho desejado (buffer circular manual)\n        if (meuHistorico.size() &gt; 500) {\n            meuHistorico.erase(meuHistorico.begin());\n        }\n    }\n}\n</code></pre> <p>API de leitura do hist\u00f3rico</p> <p>A API de leitura direta do buffer hist\u00f3rico interno est\u00e1 em desenvolvimento. Por enquanto, o padr\u00e3o recomendado \u00e9 manter seu pr\u00f3prio <code>std::vector&lt;MIDIEventData&gt;</code> como mostrado acima, usando PSRAM via <code>ps_malloc()</code> se necess\u00e1rio.</p>"},{"location":"funcionalidades/historico-psram/#alocar-vetor-em-psram","title":"Alocar Vetor em PSRAM","text":"<p>Se voc\u00ea quiser armazenar seu pr\u00f3prio hist\u00f3rico em PSRAM:</p> <pre><code>#include &lt;esp_heap_caps.h&gt;\n\nconst int MAX_HISTORY = 1000;\nMIDIEventData* historyBuffer = nullptr;\nint historySize = 0;\n\nvoid setup() {\n    midiHandler.begin();\n\n#if ESP32_HOST_MIDI_HAS_PSRAM\n    historyBuffer = (MIDIEventData*)heap_caps_malloc(\n        MAX_HISTORY * sizeof(MIDIEventData),\n        MALLOC_CAP_SPIRAM\n    );\n    if (historyBuffer) {\n        Serial.println(\"Hist\u00f3rico alocado em PSRAM\");\n    } else {\n        // Fallback para heap\n        historyBuffer = (MIDIEventData*)malloc(MAX_HISTORY * sizeof(MIDIEventData));\n    }\n#else\n    historyBuffer = (MIDIEventData*)malloc(MAX_HISTORY * sizeof(MIDIEventData));\n#endif\n}\n</code></pre>"},{"location":"funcionalidades/historico-psram/#exemplo-analisador-de-sessao","title":"Exemplo \u2014 Analisador de Sess\u00e3o","text":"<p>Coleta uma sess\u00e3o de improvisa\u00e7\u00e3o e mostra estat\u00edsticas ao final:</p> <pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n\nstd::vector&lt;MIDIEventData&gt; sessao;\nbool gravando = true;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    MIDIHandlerConfig cfg;\n    cfg.maxEvents = 20;\n    cfg.historyCapacity = 500;\n    midiHandler.begin(cfg);\n\n    Serial.println(\"Gravando sess\u00e3o... (pressione bot\u00e3o para parar)\");\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    if (gravando) {\n        for (const auto&amp; ev : midiHandler.getQueue()) {\n            if (ev.status == \"NoteOn\") {\n                sessao.push_back(ev);\n            }\n        }\n    }\n\n    // Simular fim da sess\u00e3o ap\u00f3s 30 segundos\n    if (millis() &gt; 30000 &amp;&amp; gravando) {\n        gravando = false;\n        analisarSessao();\n    }\n}\n\nvoid analisarSessao() {\n    Serial.printf(\"=== AN\u00c1LISE DA SESS\u00c3O ===\\n\");\n    Serial.printf(\"Total de notas: %d\\n\", (int)sessao.size());\n\n    // Nota mais tocada\n    int contador[128] = {0};\n    for (const auto&amp; ev : sessao) contador[ev.note]++;\n\n    int notaMaisTocada = 0;\n    for (int i = 1; i &lt; 128; i++) {\n        if (contador[i] &gt; contador[notaMaisTocada]) notaMaisTocada = i;\n    }\n\n    Serial.printf(\"Nota mais tocada: %d (vezes: %d)\\n\",\n        notaMaisTocada, contador[notaMaisTocada]);\n\n    // Velocidade m\u00e9dia\n    int somaVel = 0;\n    for (const auto&amp; ev : sessao) somaVel += ev.velocity;\n    Serial.printf(\"Velocidade m\u00e9dia: %d\\n\",\n        sessao.empty() ? 0 : somaVel / (int)sessao.size());\n}\n</code></pre>"},{"location":"funcionalidades/historico-psram/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Detec\u00e7\u00e3o de Acordes \u2192 \u2014 analisar acordes do hist\u00f3rico</li> <li>GingoAdapter \u2192 \u2014 teoria musical sobre o hist\u00f3rico</li> <li>Configura\u00e7\u00e3o \u2192 \u2014 <code>historyCapacity</code> e <code>maxEvents</code></li> </ul>"},{"location":"funcionalidades/notas-ativas/","title":"\ud83c\udfb5 Notas Ativas","text":"<p>O <code>MIDIHandler</code> mant\u00e9m um mapa interno de quais notas est\u00e3o atualmente pressionadas (NoteOn recebido mas NoteOff ainda n\u00e3o). Diversas APIs permitem consultar esse estado.</p>"},{"location":"funcionalidades/notas-ativas/#api-de-notas-ativas","title":"API de Notas Ativas","text":""},{"location":"funcionalidades/notas-ativas/#getactivenotes-string-formatada","title":"getActiveNotes() \u2014 String formatada","text":"<p>Retorna uma string com todas as notas ativas:</p> <pre><code>std::string ativas = midiHandler.getActiveNotes();\nSerial.println(ativas.c_str());\n// Exemplo: \"{C4, E4, G4}\"\n</code></pre>"},{"location":"funcionalidades/notas-ativas/#getactivenotesvector-lista-de-strings","title":"getActiveNotesVector() \u2014 Lista de strings","text":"<p>Retorna um vetor com cada nota como string:</p> <pre><code>auto notas = midiHandler.getActiveNotesVector();\n// Exemplo: [\"C4\", \"E4\", \"G4\"]\n\nfor (const auto&amp; n : notas) {\n    Serial.println(n.c_str());\n}\n</code></pre>"},{"location":"funcionalidades/notas-ativas/#getactivenotescount-quantidade","title":"getActiveNotesCount() \u2014 Quantidade","text":"<p>N\u00famero de notas atualmente pressionadas:</p> <pre><code>size_t count = midiHandler.getActiveNotesCount();\nSerial.printf(\"%d notas ativas\\n\", (int)count);\n</code></pre>"},{"location":"funcionalidades/notas-ativas/#fillactivenotes-array-booleano","title":"fillActiveNotes() \u2014 Array booleano","text":"<p>Preenche um array de 128 posi\u00e7\u00f5es (uma por nota MIDI):</p> <pre><code>bool ativas[128] = {false};\nmidiHandler.fillActiveNotes(ativas);\n\n// Verificar nota espec\u00edfica:\nif (ativas[60]) Serial.println(\"C4 est\u00e1 pressionada!\");\n\n// Listar todas as ativas:\nfor (int i = 0; i &lt; 128; i++) {\n    if (ativas[i]) {\n        Serial.printf(\"Nota %d ativa\\n\", i);\n    }\n}\n</code></pre>"},{"location":"funcionalidades/notas-ativas/#exemplo-completo","title":"Exemplo Completo","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n// Tools &gt; USB Mode \u2192 \"USB Host\"\n\nvoid setup() {\n    Serial.begin(115200);\n    midiHandler.begin();\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    // Mostrar notas ativas quando algo mudar\n    static size_t lastCount = 0;\n    size_t count = midiHandler.getActiveNotesCount();\n\n    if (count != lastCount) {\n        lastCount = count;\n\n        if (count == 0) {\n            Serial.println(\"[ sem notas ]\");\n        } else {\n            Serial.printf(\"[%d notas] %s\\n\",\n                (int)count,\n                midiHandler.getActiveNotes().c_str());\n        }\n    }\n}\n</code></pre> <p>Sa\u00edda ao tocar um acorde de D\u00f3 maior e soltar:</p> <pre><code>[1 notas] {C4}\n[2 notas] {C4, E4}\n[3 notas] {C4, E4, G4}\n[2 notas] {C4, E4}\n[1 notas] {C4}\n[ sem notas ]\n</code></pre>"},{"location":"funcionalidades/notas-ativas/#usar-para-sintese-de-audio","title":"Usar para S\u00edntese de \u00c1udio","text":"<p>O <code>fillActiveNotes()</code> \u00e9 ideal para s\u00edntese em tempo real \u2014 copie o array uma vez por frame:</p> <pre><code>bool notas[128];\nmidiHandler.fillActiveNotes(notas);\n\n// Sintetizar todas as notas ativas\nfor (int i = 0; i &lt; 128; i++) {\n    if (notas[i]) {\n        float freq = 440.0f * powf(2.0f, (i - 69) / 12.0f);\n        // addOscillator(freq);\n    }\n}\n</code></pre>"},{"location":"funcionalidades/notas-ativas/#piano-roll-com-notas-ativas","title":"Piano Roll com notas ativas","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n\n// Mostrar quais teclas est\u00e3o pressionadas (ASCII art)\nvoid printPianoRoll() {\n    bool notas[128];\n    midiHandler.fillActiveNotes(notas);\n\n    // Teclas C4 a B4 (60\u201371)\n    for (int i = 60; i &lt;= 71; i++) {\n        Serial.print(notas[i] ? \"\u2588\" : \"\u2591\");\n    }\n    Serial.println();\n}\n\nvoid loop() {\n    midiHandler.task();\n    printPianoRoll();\n    delay(50);\n}\n</code></pre>"},{"location":"funcionalidades/notas-ativas/#limpar-notas-ativas","title":"Limpar Notas Ativas","text":"<p>Em alguns casos (desconex\u00e3o, reset) voc\u00ea precisa limpar o estado:</p> <pre><code>// Zera o mapa interno de notas ativas\nmidiHandler.clearActiveNotesNow();\n</code></pre>"},{"location":"funcionalidades/notas-ativas/#getactivenotesstring-alternativa","title":"getActiveNotesString() \u2014 Alternativa","text":"<p>Alias de <code>getActiveNotes()</code> com nome alternativo:</p> <pre><code>std::string s = midiHandler.getActiveNotesString();\n// Id\u00eantico a getActiveNotes()\n</code></pre>"},{"location":"funcionalidades/notas-ativas/#monitorar-pressao-de-teclas-especificas","title":"Monitorar Press\u00e3o de Teclas Espec\u00edficas","text":"<p>Combine <code>fillActiveNotes()</code> com uma lista de notas de interesse:</p> <pre><code>const int ACORDE_CM[] = {60, 64, 67};  // C, E, G\n\nbool notas[128];\nmidiHandler.fillActiveNotes(notas);\n\nbool acordeCompleto = notas[60] &amp;&amp; notas[64] &amp;&amp; notas[67];\nif (acordeCompleto) {\n    Serial.println(\"D\u00f3 maior pressionado!\");\n}\n</code></pre>"},{"location":"funcionalidades/notas-ativas/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Detec\u00e7\u00e3o de Acordes \u2192 \u2014 agrupar notas em acordes</li> <li>GingoAdapter \u2192 \u2014 identificar nome do acorde</li> <li>Hist\u00f3rico PSRAM \u2192 \u2014 guardar hist\u00f3rico de notas</li> </ul>"},{"location":"guia/configuracao/","title":"\u2699\ufe0f Configura\u00e7\u00e3o","text":"<p>O <code>MIDIHandler</code> pode ser configurado via <code>MIDIHandlerConfig</code> antes de chamar <code>begin()</code>.</p>"},{"location":"guia/configuracao/#midihandlerconfig","title":"MIDIHandlerConfig","text":"<pre><code>struct MIDIHandlerConfig {\n    int maxEvents        = 20;    // Capacidade da fila de eventos\n    unsigned long chordTimeWindow = 0;  // Janela para detec\u00e7\u00e3o de acordes (ms)\n    int velocityThreshold = 0;   // Filtro m\u00ednimo de velocidade (0 = desabilitado)\n    int historyCapacity  = 0;    // Buffer hist\u00f3rico PSRAM (0 = desabilitado)\n    const char* bleName  = \"ESP32 MIDI BLE\";  // Nome do dispositivo BLE\n};\n</code></pre>"},{"location":"guia/configuracao/#uso-basico","title":"Uso b\u00e1sico","text":"<pre><code>MIDIHandlerConfig cfg;\ncfg.maxEvents = 30;\ncfg.bleName = \"Meu Sintetizador\";\nmidiHandler.begin(cfg);\n</code></pre>"},{"location":"guia/configuracao/#maxevents-capacidade-da-fila","title":"maxEvents \u2014 Capacidade da Fila","text":"<p><code>maxEvents</code> define quantos eventos MIDI a fila mant\u00e9m. Quando a fila atinge o limite, eventos mais antigos s\u00e3o descartados (FIFO).</p> <pre><code>// Padr\u00e3o: 20 eventos\ncfg.maxEvents = 20;\n\n// Para uso educacional (ver hist\u00f3rico longo):\ncfg.maxEvents = 50;\n\n// Para uso em loop() frequente (mais reativo):\ncfg.maxEvents = 10;\n</code></pre> <p>O que \u00e9 a fila?</p> <p>A fila (<code>getQueue()</code>) cont\u00e9m os eventos desde a \u00faltima chamada de <code>task()</code>. Se o seu <code>loop()</code> for r\u00e1pido, raramente ter\u00e1 mais de 5\u201310 eventos ao mesmo tempo.</p> <p>Voc\u00ea tamb\u00e9m pode alterar ap\u00f3s <code>begin()</code>:</p> <pre><code>midiHandler.setQueueLimit(50);\n</code></pre>"},{"location":"guia/configuracao/#chordtimewindow-deteccao-de-acordes","title":"chordTimeWindow \u2014 Detec\u00e7\u00e3o de Acordes","text":"<p>Controla como notas simult\u00e2neas s\u00e3o agrupadas no mesmo <code>chordIndex</code>.</p> <pre><code>// 0 ms (padr\u00e3o): novo acorde apenas quando TODAS as notas s\u00e3o soltas\ncfg.chordTimeWindow = 0;\n\n// 30\u201380 ms: mais reativo para teclados f\u00edsicos\n// (pequenos atrasos entre os dedos ao tocar acordes)\ncfg.chordTimeWindow = 50;\n</code></pre> <pre><code>sequenceDiagram\n    participant KEY as Teclado\n    participant HANDLER as MIDIHandler\n\n    Note over KEY,HANDLER: chordTimeWindow = 50ms\n\n    KEY-&gt;&gt;HANDLER: NoteOn C4 (t=0ms)\n    Note right of HANDLER: chordIndex = 1\n    KEY-&gt;&gt;HANDLER: NoteOn E4 (t=20ms)\n    Note right of HANDLER: chordIndex = 1 (dentro da janela)\n    KEY-&gt;&gt;HANDLER: NoteOn G4 (t=45ms)\n    Note right of HANDLER: chordIndex = 1 (dentro da janela)\n    KEY-&gt;&gt;HANDLER: NoteOn B4 (t=120ms)\n    Note right of HANDLER: chordIndex = 2 (nova janela!)</code></pre> <p>Quando usar chordTimeWindow?</p> <ul> <li>0 (padr\u00e3o): mais preciso, ideal quando voc\u00ea controla o timing (sequenciadores)</li> <li>30\u201380 ms: ideal para teclados f\u00edsicos onde os dedos chegam em tempos ligeiramente diferentes</li> </ul> <p>Veja mais em Detec\u00e7\u00e3o de Acordes \u2192</p>"},{"location":"guia/configuracao/#velocitythreshold-filtro-de-velocidade","title":"velocityThreshold \u2014 Filtro de Velocidade","text":"<p>Ignora eventos NoteOn com velocidade abaixo do limiar. \u00datil para filtrar \"ghost notes\" de sensores piezo.</p> <pre><code>// Desabilitado (padr\u00e3o) \u2014 processa todas as velocidades\ncfg.velocityThreshold = 0;\n\n// Filtrar notas muito suaves (veloc &lt; 10)\ncfg.velocityThreshold = 10;\n\n// Apenas notas fortes (percuss\u00e3o):\ncfg.velocityThreshold = 40;\n</code></pre>"},{"location":"guia/configuracao/#historycapacity-historico-em-psram","title":"historyCapacity \u2014 Hist\u00f3rico em PSRAM","text":"<p>Habilita um buffer circular de eventos que persiste al\u00e9m do limite de <code>maxEvents</code>. Usa PSRAM quando dispon\u00edvel, com fallback para heap.</p> <pre><code>// Desabilitado (padr\u00e3o)\ncfg.historyCapacity = 0;\n\n// Guardar os \u00faltimos 500 eventos\ncfg.historyCapacity = 500;\n</code></pre> <p>Tamb\u00e9m pode ser ativado ap\u00f3s <code>begin()</code>:</p> <pre><code>midiHandler.enableHistory(500);\n</code></pre> <p>PSRAM necess\u00e1rio para hist\u00f3ricos grandes</p> <p>Hist\u00f3ricos grandes (&gt; 200 eventos) devem usar ESP32-S3 com PSRAM (4 MB+). Sem PSRAM, o buffer \u00e9 alocado no heap \u2014 espa\u00e7o limitado.</p> <p>Veja mais em Hist\u00f3rico PSRAM \u2192</p>"},{"location":"guia/configuracao/#blename-nome-do-dispositivo-ble","title":"bleName \u2014 Nome do Dispositivo BLE","text":"<p>Define o nome que aparece nos apps iOS/macOS ao escanear BLE MIDI.</p> <pre><code>cfg.bleName = \"ESP32 MIDI BLE\";      // padr\u00e3o\ncfg.bleName = \"Piano ESP32\";          // qualquer string\ncfg.bleName = \"Studio Hub\";           // aparece em GarageBand, AUM, etc.\n</code></pre>"},{"location":"guia/configuracao/#macros-de-feature-detection","title":"Macros de Feature Detection","text":"<p>A biblioteca detecta automaticamente os recursos dispon\u00edveis com base no chip alvo:</p> <pre><code>// Compilado automaticamente \u2014 n\u00e3o defina manualmente\n\n// USB Host dispon\u00edvel (ESP32-S2, S3, P4)\n#if ESP32_HOST_MIDI_HAS_USB\n    // Teclado USB conectado!\n#endif\n\n// BLE dispon\u00edvel (ESP32, S3, C3, C6 \u2014 CONFIG_BT_ENABLED)\n#if ESP32_HOST_MIDI_HAS_BLE\n    bool connected = midiHandler.isBleConnected();\n#endif\n\n// PSRAM dispon\u00edvel (CONFIG_SPIRAM ou CONFIG_SPIRAM_SUPPORT)\n#if ESP32_HOST_MIDI_HAS_PSRAM\n    midiHandler.enableHistory(1000);  // 1000 eventos em PSRAM\n#endif\n\n// Ethernet MAC nativo (apenas ESP32-P4)\n#if ESP32_HOST_MIDI_HAS_ETH_MAC\n    // Use EthernetMIDIConnection com PHY externo (LAN8720)\n#endif\n</code></pre>"},{"location":"guia/configuracao/#debug-callback-raw-midi","title":"Debug Callback \u2014 Raw MIDI","text":"<p>Para inspecionar os bytes MIDI brutos antes do parsing:</p> <pre><code>void onRawMidi(const uint8_t* raw, size_t rawLen, const uint8_t* midi3) {\n    // raw     = payload USB-MIDI completo (CIN + 3 bytes)\n    // rawLen  = tamanho do raw\n    // midi3   = os 3 bytes MIDI (status, data1, data2)\n    Serial.printf(\"Raw: %02X %02X %02X\\n\",\n        midi3[0], midi3[1], midi3[2]);\n}\n\nvoid setup() {\n    midiHandler.setRawMidiCallback(onRawMidi);\n    midiHandler.begin();\n}\n</code></pre>"},{"location":"guia/configuracao/#limpar-a-fila-e-notas-ativas","title":"Limpar a Fila e Notas Ativas","text":"<pre><code>// Esvazia a fila de eventos imediatamente\nmidiHandler.clearQueue();\n\n// Zera o mapa de notas ativas (\u00fatil ao reconectar)\nmidiHandler.clearActiveNotesNow();\n</code></pre>"},{"location":"guia/configuracao/#exemplo-configuracao-completa","title":"Exemplo \u2014 Configura\u00e7\u00e3o Completa","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    MIDIHandlerConfig cfg;\n    cfg.maxEvents         = 30;          // fila maior\n    cfg.chordTimeWindow   = 50;          // agrupar notas de acordes\n    cfg.velocityThreshold = 5;           // ignorar ghost notes\n    cfg.historyCapacity   = 500;         // guardar hist\u00f3rico em PSRAM\n    cfg.bleName           = \"Meu ESP32\"; // nome no BLE\n\n    midiHandler.begin(cfg);\n}\n</code></pre>"},{"location":"guia/configuracao/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Transportes \u2192 \u2014 adicionar mais transportes</li> <li>Detec\u00e7\u00e3o de Acordes \u2192 \u2014 usar <code>chordTimeWindow</code></li> <li>Hist\u00f3rico PSRAM \u2192 \u2014 usar <code>historyCapacity</code></li> </ul>"},{"location":"guia/instalacao/","title":"\ud83d\udce6 Instala\u00e7\u00e3o","text":"<p>A biblioteca suporta tr\u00eas ambientes de desenvolvimento: Arduino IDE, PlatformIO e ESP-IDF (componente Arduino).</p>"},{"location":"guia/instalacao/#requisitos","title":"Requisitos","text":"<p>Vers\u00e3o m\u00ednima do pacote ESP32</p> <p>USB Host e USB Device requerem arduino-esp32 \u2265 3.0.0 (TinyUSB MIDI integrado). Verifique em: <code>Tools &gt; Boards Manager \u2192 \"esp32\" by Espressif</code></p>"},{"location":"guia/instalacao/#arduino-ide","title":"Arduino IDE","text":""},{"location":"guia/instalacao/#passo-1-instalar-a-biblioteca-principal","title":"Passo 1 \u2014 Instalar a biblioteca principal","text":"<pre><code>Sketch \u2192 Include Library \u2192 Manage Libraries...\n\u2192 Pesquisar: \"ESP32_Host_MIDI\"\n\u2192 Instalar: ESP32_Host_MIDI by sauloverissimo\n</code></pre>"},{"location":"guia/instalacao/#passo-2-instalar-o-pacote-de-placas-esp32","title":"Passo 2 \u2014 Instalar o pacote de placas ESP32","text":"<pre><code>Tools \u2192 Boards Manager\n\u2192 Pesquisar: \"esp32\"\n\u2192 Instalar: esp32 by Espressif Systems (vers\u00e3o \u2265 3.0.0)\n</code></pre>"},{"location":"guia/instalacao/#passo-3-instalar-bibliotecas-opcionais-por-transporte","title":"Passo 3 \u2014 Instalar bibliotecas opcionais (por transporte)","text":"<p>Instale apenas as que voc\u00ea vai usar:</p> Transporte Biblioteca a instalar RTP-MIDI (WiFi) <code>lathoub/Arduino-AppleMIDI-Library</code> (v3.x) Ethernet MIDI <code>lathoub/Arduino-AppleMIDI-Library</code> + <code>arduino-libraries/Ethernet</code> OSC <code>CNMAT/OSC</code> Detec\u00e7\u00e3o de acordes <code>sauloverissimo/gingoduino</code> USB Host / BLE / ESP-NOW J\u00e1 inclu\u00eddo no arduino-esp32 USB Device J\u00e1 inclu\u00eddo no arduino-esp32 (TinyUSB) UART / DIN-5 Sem depend\u00eancias extras MIDI 2.0 UDP Sem depend\u00eancias extras <pre><code>Sketch \u2192 Include Library \u2192 Manage Libraries...\n\u2192 Pesquisar e instalar cada uma acima\n</code></pre>"},{"location":"guia/instalacao/#passo-4-configurar-o-modo-usb-para-usb-host","title":"Passo 4 \u2014 Configurar o modo USB (para USB Host)","text":"<pre><code>Tools \u2192 USB Mode \u2192 \"USB Host\"\n</code></pre> <p>USB Device</p> <p>Para o transporte USB Device (ESP32 se apresenta como interface MIDI), use: <code>Tools \u2192 USB Mode \u2192 \"USB-OTG (TinyUSB)\"</code></p>"},{"location":"guia/instalacao/#platformio","title":"PlatformIO","text":"<p>Adicione ao seu <code>platformio.ini</code>:</p> <pre><code>[env:esp32-s3-devkitc-1]\nplatform = espressif32\nboard    = esp32-s3-devkitc-1\nframework = arduino\n\nlib_deps =\n    sauloverissimo/ESP32_Host_MIDI\n    ; Descomente conforme os transportes que usar:\n    ; lathoub/Arduino-AppleMIDI-Library  ; RTP-MIDI + Ethernet MIDI\n    ; arduino-libraries/Ethernet          ; Ethernet MIDI\n    ; CNMAT/OSC                           ; OSC\n    ; sauloverissimo/gingoduino           ; Detec\u00e7\u00e3o de acordes\n\n; Para USB Host:\nbuild_flags =\n    -D ARDUINO_USB_MODE=0\n    -D ARDUINO_USB_CDC_ON_BOOT=0\n</code></pre> <p>Para USB Device:</p> <pre><code>build_flags =\n    -D ARDUINO_USB_MODE=1\n    -D ARDUINO_USB_CDC_ON_BOOT=1\n</code></pre>"},{"location":"guia/instalacao/#instalacao-manual-symlink","title":"Instala\u00e7\u00e3o Manual (symlink)","text":"<p>Se voc\u00ea desenvolveu a biblioteca localmente e quer testar os exemplos no Arduino IDE:</p> <pre><code># Criar symlink da sua pasta de desenvolvimento para o Arduino libraries\nln -s /home/saulo/Libraries/ESP32_Host_MIDI /home/saulo/Arduino/libraries/ESP32_Host_MIDI\n</code></pre> <p>Isso permite editar os fontes diretamente sem copiar arquivos.</p>"},{"location":"guia/instalacao/#verificacao-da-instalacao","title":"Verifica\u00e7\u00e3o da Instala\u00e7\u00e3o","text":"<p>Ap\u00f3s instalar, abra um dos exemplos:</p> <pre><code>File \u2192 Examples \u2192 ESP32_Host_MIDI \u2192 UART-MIDI-Basic\n</code></pre> <p>Compile (sem upload) para verificar que todas as depend\u00eancias est\u00e3o resolvidas. Se compilar sem erros, a instala\u00e7\u00e3o est\u00e1 correta.</p> <p>Exemplo m\u00ednimo \u2014 sem hardware USB</p> <p><code>UART-MIDI-Basic</code> \u00e9 o exemplo mais simples para verificar a instala\u00e7\u00e3o, pois n\u00e3o requer hardware USB-OTG espec\u00edfico.</p>"},{"location":"guia/instalacao/#tabela-de-compatibilidade-por-chip","title":"Tabela de Compatibilidade por Chip","text":"<pre><code>graph TD\n    subgraph CHIPS[\"Chips ESP32\"]\n        S3[\"ESP32-S3\\n\u2705 USB Host\\n\u2705 BLE\\n\u2705 USB Device\\n\u2705 WiFi\\n\u2705 ESP-NOW\\n\u2705 UART\"]\n        S2[\"ESP32-S2\\n\u2705 USB Host\\n\u274c BLE\\n\u2705 USB Device\\n\u2705 WiFi\\n\u274c ESP-NOW\\n\u2705 UART\"]\n        P4[\"ESP32-P4\\n\u2705 USB Host HS\\n\u274c BLE\\n\u2705 USB Device\\n\u274c WiFi\\n\u274c ESP-NOW\\n\u2705 UART \u00d75\\n\u2705 Ethernet MAC\"]\n        CLASSIC[\"ESP32 Classic\\n\u274c USB Host\\n\u2705 BLE\\n\u274c USB Device\\n\u2705 WiFi\\n\u2705 ESP-NOW\\n\u2705 UART\"]\n        C3[\"ESP32-C3/C6/H2\\n\u274c USB Host\\n\u2705 BLE\\n\u274c USB Device\\n\u2705 WiFi\\n\u2705 ESP-NOW\\n\u2705 UART\"]\n    end\n\n    style S3 fill:#1B5E20,color:#fff,stroke:#2E7D32\n    style S2 fill:#1565C0,color:#fff,stroke:#0D47A1\n    style P4 fill:#4A148C,color:#fff,stroke:#6A1B9A\n    style CLASSIC fill:#BF360C,color:#fff,stroke:#E64A19\n    style C3 fill:#37474F,color:#fff,stroke:#546E7A</code></pre> <p>Placa recomendada</p> <p>LilyGO T-Display-S3 = ESP32-S3 + display ST7789 1.9\" + bateria LiPo. \u00c9 a placa mais vers\u00e1til para ESP32_Host_MIDI: USB Host, BLE, WiFi, ESP-NOW e display tudo em um.</p>"},{"location":"guia/instalacao/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Primeiros Passos \u2192 \u2014 primeiro sketch funcionando</li> <li>Configura\u00e7\u00e3o \u2192 \u2014 op\u00e7\u00f5es do <code>MIDIHandlerConfig</code></li> </ul>"},{"location":"guia/introducao/","title":"\ud83c\udf9b\ufe0f Introdu\u00e7\u00e3o","text":"<p>ESP32_Host_MIDI \u00e9 uma biblioteca Arduino de c\u00f3digo aberto que transforma o ESP32 em um hub MIDI universal com suporte a 9 transportes simult\u00e2neos, todos operando pela mesma API limpa de eventos.</p>"},{"location":"guia/introducao/#o-que-e-a-biblioteca","title":"O Que \u00c9 a Biblioteca","text":"<p>A ideia central \u00e9 simples: n\u00e3o importa de onde o MIDI vem \u2014 USB, Bluetooth, WiFi, cabo serial, r\u00e1dio \u2014 ele chega sempre na mesma fila de eventos (<code>getQueue()</code>), com o mesmo formato (<code>MIDIEventData</code>), pronto para processar.</p> <pre><code>for (const auto&amp; ev : midiHandler.getQueue()) {\n    ev.status;      // \"NoteOn\", \"NoteOff\", \"ControlChange\", \"PitchBend\"...\n    ev.channel;     // 1\u201316\n    ev.note;        // n\u00famero MIDI (0\u2013127)\n    ev.noteOctave;  // \"C4\", \"D#5\", \"G3\"...\n    ev.velocity;    // 0\u2013127\n    ev.timestamp;   // millis() na chegada\n    ev.chordIndex;  // agrupa notas simult\u00e2neas\n}\n</code></pre> <p>Ao mesmo tempo, <code>midiHandler.sendNoteOn()</code> e outros m\u00e9todos de envio transmitem para todos os transportes ativos simultaneamente. Um evento que chega pelo USB pode sair imediatamente pelo BLE, pelo DIN-5 e pelo WiFi \u2014 sem nenhum c\u00f3digo extra.</p>"},{"location":"guia/introducao/#os-9-transportes","title":"Os 9 Transportes","text":"<pre><code>mindmap\n  root((ESP32\\nHost MIDI))\n    USB Host\n      ESP32-S3 / S2 / P4\n      Teclados class-compliant\n      Lat\u00eancia &lt; 1 ms\n    BLE MIDI\n      Qualquer ESP32 com BT\n      iOS \u00b7 macOS \u00b7 Android\n      Lat\u00eancia 3-15 ms\n    USB Device\n      ESP32-S3 / S2 / P4\n      Aparece como interface USB\n      Lat\u00eancia &lt; 1 ms\n    ESP-NOW\n      Qualquer ESP32\n      Mesh P2P sem router\n      Lat\u00eancia 1-5 ms\n    RTP-MIDI WiFi\n      AppleMIDI / RFC 6295\n      macOS \u00b7 iOS \u00b7 Logic Pro\n      Lat\u00eancia 5-20 ms\n    Ethernet MIDI\n      W5500 SPI ou P4 nativo\n      Ideal para est\u00fadios\n      Lat\u00eancia 2-10 ms\n    OSC\n      WiFi UDP bidirecional\n      Max/MSP \u00b7 PD \u00b7 SC\n      Lat\u00eancia 5-15 ms\n    UART / DIN-5\n      Qualquer ESP32\n      Sintetizadores vintage\n      Lat\u00eancia &lt; 1 ms\n    MIDI 2.0 UDP\n      UMP over UDP\n      16-bit velocity\n      Lat\u00eancia 5-20 ms</code></pre>"},{"location":"guia/introducao/#arquitetura-de-software","title":"Arquitetura de Software","text":""},{"location":"guia/introducao/#separacao-por-cores-do-freertos","title":"Separa\u00e7\u00e3o por Cores do FreeRTOS","text":"<p>O ESP32 tem dois n\u00facleos. A biblioteca usa essa separa\u00e7\u00e3o para garantir baixa lat\u00eancia:</p> <pre><code>graph TD\n    subgraph CORE0[\"\ud83d\udd35 Core 0 \u2014 Drivers e Stack\"]\n        USB_TASK[\"USB Host Task\\n(USBConnection)\"]\n        BLE_STACK[\"Pilha BLE\\n(BLEConnection)\"]\n        WIFI[\"Pilha WiFi / Ethernet\\n(RTP-MIDI, OSC, ESP-NOW)\"]\n    end\n\n    subgraph CORE1[\"\ud83d\udfe2 Core 1 \u2014 Seu C\u00f3digo\"]\n        LOOP[\"loop()\"]\n        TASK[\"midiHandler.task()\"]\n        USER[\"Seu c\u00f3digo\\n(display, synth, etc.)\"]\n    end\n\n    subgraph BUFFERS[\"\ud83d\udd04 Ring Buffers (thread-safe)\"]\n        RB1[\"portMUX spinlock\\nbuffer USB\"]\n        RB2[\"portMUX spinlock\\nbuffer BLE\"]\n        RB3[\"portMUX spinlock\\nbuffers WiFi\"]\n    end\n\n    USB_TASK --&gt; RB1\n    BLE_STACK --&gt; RB2\n    WIFI --&gt; RB3\n    RB1 --&gt; TASK\n    RB2 --&gt; TASK\n    RB3 --&gt; TASK\n    TASK --&gt; LOOP\n    LOOP --&gt; USER\n\n    style CORE0 fill:#1A237E,color:#fff,stroke:#283593\n    style CORE1 fill:#1B5E20,color:#fff,stroke:#2E7D32\n    style BUFFERS fill:#37474F,color:#fff,stroke:#546E7A</code></pre>"},{"location":"guia/introducao/#fluxo-de-um-evento-noteon","title":"Fluxo de um Evento NoteOn","text":"<pre><code>sequenceDiagram\n    participant USB as \ud83d\udd0c Teclado USB\n    participant DRIVER as USB Host Driver\n    participant BUF as Ring Buffer\n    participant HANDLER as MIDIHandler\n    participant USER as Seu C\u00f3digo\n\n    USB-&gt;&gt;DRIVER: Pacote USB-MIDI (4 bytes)\n    DRIVER-&gt;&gt;BUF: Armazena com portMUX (Core 0)\n    loop Cada loop()\n        USER-&gt;&gt;HANDLER: midiHandler.task()\n        HANDLER-&gt;&gt;BUF: L\u00ea mensagens pendentes\n        BUF-&gt;&gt;HANDLER: [0x09, 0x90, 0x3C, 0x64]\n        HANDLER-&gt;&gt;HANDLER: Parseia \u2192 MIDIEventData\n        Note over HANDLER: status=\"NoteOn\"&lt;br/&gt;note=60 (C4)&lt;br/&gt;velocity=100\n        HANDLER-&gt;&gt;USER: getQueue() retorna evento\n    end</code></pre>"},{"location":"guia/introducao/#camadas-da-biblioteca","title":"Camadas da Biblioteca","text":"Camada Arquivo Responsabilidade Feature detection <code>ESP32_Host_MIDI.h</code> Detecta USB, BLE, PSRAM por chip Transporte abstrato <code>MIDITransport.h</code> Interface comum para todos transportes Processador central <code>MIDIHandler.h/.cpp</code> Fila, accordes, notas ativas, envio Configura\u00e7\u00e3o <code>MIDIHandlerConfig.h</code> Struct de configura\u00e7\u00e3o do handler Transportes built-in <code>USBConnection</code>, <code>BLEConnection</code>, <code>ESPNowConnection</code> Registrados automaticamente Transportes externos <code>UART</code>, <code>RTP-MIDI</code>, <code>Ethernet</code>, <code>OSC</code>, <code>MIDI2</code>, <code>USBDevice</code> Inclu\u00eddos manualmente no sketch Integra\u00e7\u00e3o teoria <code>GingoAdapter.h</code> Bridge com Gingoduino MIDI 2.0 <code>MIDI2Support.h</code> Parser, builder e scaler UMP"},{"location":"guia/introducao/#casos-de-uso-tipicos","title":"Casos de Uso T\u00edpicos","text":""},{"location":"guia/introducao/#hub-midi-de-palco","title":"Hub MIDI de Palco","text":"<pre><code>Teclado USB \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\niPhone BLE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\nESP-NOW (pedais) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u25ba MIDIHandler \u2500\u2500\u25ba USB Device \u2192 Computador FOH\n                                                       \u2502              \u2500\u2500\u25ba DIN-5 \u2192 Rack de efeitos\n                                                       \u2502              \u2500\u2500\u25ba ESP-NOW \u2192 Outros performers\n</code></pre>"},{"location":"guia/introducao/#interface-de-estudio","title":"Interface de Est\u00fadio","text":"<pre><code>macOS (RTP-MIDI via WiFi) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nSintetizador DIN-5 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u25ba MIDIHandler \u2500\u2500\u25ba USB Device \u2192 DAW\niPad (BLE MIDI) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2500\u2500\u25ba DIN-5 (THRU) \u2192 Outros synths\n</code></pre>"},{"location":"guia/introducao/#experimento-midi-20","title":"Experimento MIDI 2.0","text":"<pre><code>ESP32-A (teclado USB) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba MIDIHandler \u2500\u2500\u25ba MIDI2UDPConnection \u2500\u2500\u25ba UDP \u2192\n\u2500\u2500 UDP \u2192 MIDI2UDPConnection \u2500\u2500\u25ba MIDIHandler \u2500\u2500\u25ba ESP32-B (display, s\u00edntese)\n                                               (16-bit velocity, 32-bit CC)\n</code></pre>"},{"location":"guia/introducao/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Instala\u00e7\u00e3o \u2192 \u2014 instalar via Arduino IDE ou PlatformIO</li> <li>Primeiros Passos \u2192 \u2014 primeiro sketch funcionando em 5 minutos</li> <li>Configura\u00e7\u00e3o \u2192 \u2014 <code>MIDIHandlerConfig</code> e op\u00e7\u00f5es avan\u00e7adas</li> </ul>"},{"location":"guia/primeiros-passos/","title":"\ud83d\ude80 Primeiros Passos","text":"<p>Neste guia voc\u00ea ter\u00e1 o ESP32 recebendo e enviando MIDI em menos de 5 minutos.</p>"},{"location":"guia/primeiros-passos/#pre-requisito","title":"Pr\u00e9-requisito","text":"<ul> <li>Biblioteca instalada (veja Instala\u00e7\u00e3o)</li> <li>ESP32-S3 com cabo USB-OTG ou qualquer ESP32 com Bluetooth</li> </ul>"},{"location":"guia/primeiros-passos/#passo-1-o-sketch-mais-simples","title":"Passo 1 \u2014 O Sketch Mais Simples","text":"<p>Este sketch imprime todos os eventos MIDI recebidos via USB Host ou BLE no Serial Monitor:</p> <pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n// Arduino IDE: Tools &gt; USB Mode \u2192 \"USB Host\"\n\nvoid setup() {\n    Serial.begin(115200);\n    midiHandler.begin();  // (1)\n}\n\nvoid loop() {\n    midiHandler.task();   // (2)\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {  // (3)\n        Serial.printf(\"%-12s %-5s ch=%d  vel=%d\\n\",\n            ev.status.c_str(),    // \"NoteOn\" | \"NoteOff\" | \"ControlChange\"...\n            ev.noteOctave.c_str(), // \"C4\", \"D#5\"...\n            ev.channel,\n            ev.velocity);\n    }\n}\n</code></pre> <p>Anota\u00e7\u00f5es:</p> <ol> <li><code>begin()</code> inicializa automaticamente USB Host (se o chip suportar) e BLE (se habilitado)</li> <li><code>task()</code> deve ser chamado em todo <code>loop()</code> \u2014 ele drena os ring buffers de todos os transportes</li> <li><code>getQueue()</code> retorna a fila de eventos desde a \u00faltima chamada de <code>task()</code></li> </ol>"},{"location":"guia/primeiros-passos/#passo-2-acessar-campos-do-evento","title":"Passo 2 \u2014 Acessar Campos do Evento","text":"<p>Cada evento tem os seguintes campos:</p> <pre><code>for (const auto&amp; ev : midiHandler.getQueue()) {\n    // Identifica\u00e7\u00e3o\n    ev.index;        // Contador global de eventos (\u00fanico, crescente)\n    ev.timestamp;    // millis() no momento da chegada\n    ev.delay;        // \u0394t em ms desde o evento anterior\n\n    // Tipo de mensagem\n    ev.status;       // \"NoteOn\" | \"NoteOff\" | \"ControlChange\" |\n                     // \"ProgramChange\" | \"PitchBend\" | \"ChannelPressure\"\n    ev.channel;      // Canal MIDI: 1\u201316\n\n    // Nota (apenas NoteOn / NoteOff)\n    ev.note;         // N\u00famero MIDI: 0\u2013127 (60 = C4 = D\u00f3 central)\n    ev.noteName;     // \"C\", \"C#\", \"D\"... (sem oitava)\n    ev.noteOctave;   // \"C4\", \"D#5\", \"G3\"... (com oitava)\n    ev.velocity;     // Velocidade: 0\u2013127 (tamb\u00e9m: valor CC, program, pressure)\n\n    // Agrupamento de acordes\n    ev.chordIndex;   // Notas simult\u00e2neas compartilham o mesmo chordIndex\n\n    // Pitch Bend (apenas PitchBend)\n    ev.pitchBend;    // 0\u201316383 (centro = 8192)\n}\n</code></pre>"},{"location":"guia/primeiros-passos/#exemplo-apenas-noteon","title":"Exemplo \u2014 Apenas NoteOn","text":"<pre><code>for (const auto&amp; ev : midiHandler.getQueue()) {\n    if (ev.status == \"NoteOn\" &amp;&amp; ev.velocity &gt; 0) {\n        Serial.printf(\"Nota: %s  Velocidade: %d  Canal: %d\\n\",\n            ev.noteOctave.c_str(),\n            ev.velocity,\n            ev.channel);\n    }\n}\n</code></pre>"},{"location":"guia/primeiros-passos/#exemplo-control-change","title":"Exemplo \u2014 Control Change","text":"<pre><code>for (const auto&amp; ev : midiHandler.getQueue()) {\n    if (ev.status == \"ControlChange\") {\n        // ev.note = n\u00famero do controlador (CC#)\n        // ev.velocity = valor do controlador (0\u2013127)\n        Serial.printf(\"CC #%d = %d  (canal %d)\\n\",\n            ev.note, ev.velocity, ev.channel);\n    }\n}\n</code></pre>"},{"location":"guia/primeiros-passos/#passo-3-enviar-midi-de-volta","title":"Passo 3 \u2014 Enviar MIDI de Volta","text":"<p>Todos os m\u00e9todos de envio transmitem simultaneamente para todos os transportes ativos:</p> <pre><code>// NoteOn: canal 1, nota C4 (60), velocidade 100\nmidiHandler.sendNoteOn(1, 60, 100);\n\n// NoteOff: canal 1, nota C4 (60), velocidade 0\nmidiHandler.sendNoteOff(1, 60, 0);\n\n// Control Change: canal 1, CC #7 (volume) = 127\nmidiHandler.sendControlChange(1, 7, 127);\n\n// Program Change: canal 1, programa 0\nmidiHandler.sendProgramChange(1, 0);\n\n// Pitch Bend: canal 1, valor -8192 a +8191 (0 = centro)\nmidiHandler.sendPitchBend(1, 4096);  // +0.5 semitom\n</code></pre>"},{"location":"guia/primeiros-passos/#exemplo-echo-midi-loopback","title":"Exemplo \u2014 Echo MIDI (loopback)","text":"<p>Recebe qualquer NoteOn e reenvia para todos os transportes:</p> <pre><code>void loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        if (ev.status == \"NoteOn\") {\n            // Reenvia com velocidade dobrada (limitada a 127)\n            uint8_t vel = min(ev.velocity * 2, 127);\n            midiHandler.sendNoteOn(ev.channel, ev.note, vel);\n        }\n        if (ev.status == \"NoteOff\") {\n            midiHandler.sendNoteOff(ev.channel, ev.note, 0);\n        }\n    }\n}\n</code></pre>"},{"location":"guia/primeiros-passos/#passo-4-verificar-conexao-ble","title":"Passo 4 \u2014 Verificar Conex\u00e3o BLE","text":"<pre><code>void loop() {\n    midiHandler.task();\n\n#if ESP32_HOST_MIDI_HAS_BLE\n    if (midiHandler.isBleConnected()) {\n        Serial.println(\"BLE MIDI conectado!\");\n    }\n#endif\n}\n</code></pre> <p>Conectar via iOS</p> <ol> <li>Abra GarageBand no iPhone</li> <li>Toque em \"+\" \u2192 M\u00fasica Mixada \u2192 Iniciar</li> <li>Menu de configura\u00e7\u00f5es \u2192 Conectar dispositivo MIDI via Bluetooth</li> <li>O ESP32 aparecer\u00e1 como \"ESP32 MIDI BLE\" (ou o nome configurado)</li> </ol>"},{"location":"guia/primeiros-passos/#passo-5-sketch-completo-com-usb-ble","title":"Passo 5 \u2014 Sketch Completo com USB + BLE","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n// Arduino IDE: Tools &gt; USB Mode \u2192 \"USB Host\"\n\nvoid setup() {\n    Serial.begin(115200);\n    delay(1000);\n    Serial.println(\"ESP32 Host MIDI \u2014 Iniciando...\");\n\n    MIDIHandlerConfig cfg;\n    cfg.maxEvents = 20;         // capacidade da fila\n    cfg.chordTimeWindow = 50;   // ms para agrupar acordes\n    midiHandler.begin(cfg);\n\n    Serial.println(\"Pronto! Conecte um teclado USB ou use BLE.\");\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        if (ev.status == \"NoteOn\" &amp;&amp; ev.velocity &gt; 0) {\n            Serial.printf(\"[NoteOn]  %s  vel=%3d  ch=%d  t=%lums\\n\",\n                ev.noteOctave.c_str(),\n                ev.velocity,\n                ev.channel,\n                ev.timestamp);\n        } else if (ev.status == \"NoteOff\" || ev.velocity == 0) {\n            Serial.printf(\"[NoteOff] %s             ch=%d\\n\",\n                ev.noteOctave.c_str(),\n                ev.channel);\n        } else if (ev.status == \"ControlChange\") {\n            Serial.printf(\"[CC]      #%3d = %3d    ch=%d\\n\",\n                ev.note, ev.velocity, ev.channel);\n        } else if (ev.status == \"PitchBend\") {\n            Serial.printf(\"[Pitch]   %d (centro=8192)  ch=%d\\n\",\n                ev.pitchBend, ev.channel);\n        }\n    }\n}\n</code></pre>"},{"location":"guia/primeiros-passos/#fluxo-de-inicializacao","title":"Fluxo de Inicializa\u00e7\u00e3o","text":"<pre><code>sequenceDiagram\n    participant SKETCH as Seu Sketch\n    participant HANDLER as MIDIHandler\n    participant USB as USBConnection\n    participant BLE as BLEConnection\n\n    SKETCH-&gt;&gt;HANDLER: midiHandler.begin()\n    HANDLER-&gt;&gt;HANDLER: L\u00ea MIDIHandlerConfig\n    HANDLER-&gt;&gt;USB: usbTransport.begin()\n    Note over USB: Inicia FreeRTOS task\\nno Core 0\n    HANDLER-&gt;&gt;BLE: bleTransport.begin(bleName)\n    Note over BLE: Inicia stack BLE\\ne advertising\n    HANDLER--&gt;&gt;SKETCH: Pronto\n\n    loop Cada loop()\n        SKETCH-&gt;&gt;HANDLER: midiHandler.task()\n        HANDLER-&gt;&gt;USB: usb.task()\n        HANDLER-&gt;&gt;BLE: ble.task()\n        USB--&gt;&gt;HANDLER: Eventos do ring buffer\n        BLE--&gt;&gt;HANDLER: Eventos do ring buffer\n        HANDLER--&gt;&gt;SKETCH: getQueue() com eventos\n    end</code></pre>"},{"location":"guia/primeiros-passos/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Configura\u00e7\u00e3o \u2192 \u2014 ajustar <code>MIDIHandlerConfig</code>, filtros e hist\u00f3rico</li> <li>Transportes \u2192 \u2014 adicionar mais transportes (RTP-MIDI, UART, OSC...)</li> <li>Funcionalidades \u2192 \u2014 detec\u00e7\u00e3o de acordes, notas ativas</li> </ul>"},{"location":"transportes/ble-midi/","title":"\ud83d\udcf1 BLE MIDI","text":"<p>O ESP32 se anuncia como um perif\u00e9rico BLE MIDI 1.0. Dispositivos iOS (GarageBand, AUM, Moog), macOS (Audio MIDI Setup) e Android conectam sem qualquer ritual de pareamento.</p>"},{"location":"transportes/ble-midi/#caracteristicas","title":"Caracter\u00edsticas","text":"Aspecto Detalhe Protocolo BLE MIDI 1.0 (Spec Apple/MMA) UUID do servi\u00e7o <code>03B80E5A-EDE8-4B33-A751-6CE34EC4C700</code> Alcance ~30 m (linha de vis\u00e3o) Lat\u00eancia 3\u201315 ms Chips suportados ESP32, ESP32-S3, ESP32-C3, ESP32-C6, ESP32-H2 Chips sem BLE ESP32-S2, ESP32-P4"},{"location":"transportes/ble-midi/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    MIDIHandlerConfig cfg;\n    cfg.bleName = \"Meu Sintetizador\";  // Nome que aparece no iOS/macOS\n    midiHandler.begin(cfg);\n\n    // O BLE come\u00e7a a anunciar automaticamente\n    Serial.println(\"BLE MIDI aguardando conex\u00e3o...\");\n}\n\nvoid loop() {\n    midiHandler.task();\n\n#if ESP32_HOST_MIDI_HAS_BLE\n    static bool wasConnected = false;\n    bool connected = midiHandler.isBleConnected();\n\n    if (connected &amp;&amp; !wasConnected) {\n        Serial.println(\"\u2705 BLE MIDI conectado!\");\n    } else if (!connected &amp;&amp; wasConnected) {\n        Serial.println(\"\u274c BLE MIDI desconectado.\");\n    }\n    wasConnected = connected;\n#endif\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"[BLE] %s %s vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.velocity);\n    }\n}\n</code></pre>"},{"location":"transportes/ble-midi/#conectar-no-ios","title":"Conectar no iOS","text":"<pre><code>sequenceDiagram\n    participant ESP32 as ESP32 (BLE MIDI Server)\n    participant IOS as iPhone (GarageBand)\n\n    ESP32-&gt;&gt;ESP32: begin() \u2014 inicia advertising\n    Note over ESP32: Anuncia UUID MIDI BLE:&lt;br/&gt;03B80E5A-EDE8-4B33-...\n\n    IOS-&gt;&gt;IOS: Abrir GarageBand\n    IOS-&gt;&gt;IOS: Menu \u2192 Conectar MIDI Bluetooth\n    IOS-&gt;&gt;ESP32: Scan BLE\n    ESP32--&gt;&gt;IOS: Anuncio: \"Meu Sintetizador\"\n    IOS-&gt;&gt;ESP32: Connect + GATT handshake\n    ESP32--&gt;&gt;IOS: MIDI Characteristic dispon\u00edvel\n\n    loop Tocando notas\n        IOS-&gt;&gt;ESP32: BLE NOTIFY (NoteOn)\n        ESP32-&gt;&gt;ESP32: dispatchMidiData()\n        Note over ESP32: MIDIEventData na fila\n    end</code></pre>"},{"location":"transportes/ble-midi/#passo-a-passo-no-garageband-ios","title":"Passo a passo no GarageBand (iOS)","text":"<ol> <li>Abra o GarageBand</li> <li>Selecione qualquer instrumento</li> <li>Toque no \u00edcone Settings (engrenagem)</li> <li>Toque em Bluetooth MIDI Devices</li> <li>O ESP32 aparece com o nome configurado \u2014 toque para conectar</li> </ol>"},{"location":"transportes/ble-midi/#passo-a-passo-no-macos","title":"Passo a passo no macOS","text":"<ol> <li>Abra Audio MIDI Setup (<code>/Applications/Utilities/</code>)</li> <li>Clique em Window \u2192 Show MIDI Studio</li> <li>Clique em Bluetooth (\u00edcone Bluetooth)</li> <li>O ESP32 aparece \u2014 clique em Connect</li> </ol>"},{"location":"transportes/ble-midi/#enviar-midi-via-ble","title":"Enviar MIDI via BLE","text":"<p>O BLE MIDI suporta envio completo. Quando voc\u00ea chama <code>sendNoteOn()</code>, o dado \u00e9 enviado via BLE NOTIFY para o dispositivo conectado:</p> <pre><code>// Envia para TODOS os transportes (incluindo BLE)\nmidiHandler.sendNoteOn(1, 60, 100);   // canal 1, C4, vel 100\nmidiHandler.sendNoteOff(1, 60, 0);    // libera C4\nmidiHandler.sendControlChange(1, 7, 127);  // volume m\u00e1ximo\nmidiHandler.sendPitchBend(1, 0);      // centro (8192 no raw)\n\n// Envio raw BLE (legado \u2014 use sendRaw() preferencialmente)\nuint8_t msg[] = {0x90, 0x3C, 0x64};  // NoteOn C4 vel=100\nmidiHandler.sendBleRaw(msg, 3);\n</code></pre>"},{"location":"transportes/ble-midi/#configuracoes-avancadas","title":"Configura\u00e7\u00f5es Avan\u00e7adas","text":""},{"location":"transportes/ble-midi/#verificar-conexao-antes-de-enviar","title":"Verificar conex\u00e3o antes de enviar","text":"<pre><code>void loop() {\n    midiHandler.task();\n\n#if ESP32_HOST_MIDI_HAS_BLE\n    if (midiHandler.isBleConnected()) {\n        // Enviar apenas se BLE estiver conectado\n        midiHandler.sendNoteOn(1, 60, 100);\n        delay(500);\n        midiHandler.sendNoteOff(1, 60, 0);\n        delay(500);\n    }\n#endif\n}\n</code></pre>"},{"location":"transportes/ble-midi/#reconexao-automatica","title":"Reconex\u00e3o autom\u00e1tica","text":"<p>O BLE reinicia o advertising automaticamente ap\u00f3s desconex\u00e3o. N\u00e3o \u00e9 necess\u00e1rio nenhum c\u00f3digo extra \u2014 quando o iOS/macOS se desconectar, o ESP32 voltar\u00e1 a anunciar em segundos.</p>"},{"location":"transportes/ble-midi/#aplicativos-compativeis","title":"Aplicativos Compat\u00edveis","text":"Plataforma Aplicativo Uso iOS GarageBand Instrumento completo, grava\u00e7\u00e3o iOS AUM Mixer e host de plugins AUv3 iOS Moog apps Minimoog, Model D, Animoog iOS NLog Synth Pro Sintetizador polif\u00f4nico iOS Loopy Pro Looper para ao vivo macOS GarageBand Instrumento, grava\u00e7\u00e3o macOS Logic Pro DAW profissional macOS Ableton Live Com Bluetooth MIDI habilitado Android MIDI+BTLE Bridge BLE MIDI para apps Android Android Caustic 3 Sintetizador com BLE MIDI"},{"location":"transportes/ble-midi/#diagrama-de-hardware","title":"Diagrama de Hardware","text":"<pre><code>ESP32-S3 (ou qualquer ESP32 com BT)\n    |\n    |\u2500\u2500 Antena interna / externa BLE\n    |\n    \u2195 Bluetooth LE 5.0\n    |\n    \u2193\niPhone / iPad / macOS / Android\n</code></pre> <p>N\u00e3o h\u00e1 hardware adicional necess\u00e1rio \u2014 o ESP32 j\u00e1 tem a antena BLE integrada.</p>"},{"location":"transportes/ble-midi/#exemplos-com-ble-midi","title":"Exemplos com BLE MIDI","text":"Exemplo Descri\u00e7\u00e3o <code>T-Display-S3-BLE-Sender</code> Sequenciador BLE \u2014 ESP32 envia MIDI para iOS <code>T-Display-S3-BLE-Receiver</code> Receptor BLE \u2014 iOS envia para ESP32 BLE MIDI Receiver \u2014 iPhone \u2192 ESP32 BLE MIDI Sender \u2014 ESP32 \u2192 iOS"},{"location":"transportes/ble-midi/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>USB Host \u2192 \u2014 use USB + BLE simultaneamente</li> <li>ESP-NOW \u2192 \u2014 mesh sem fio entre ESP32 (sem iOS/macOS)</li> <li>RTP-MIDI \u2192 \u2014 WiFi com auto-descoberta no macOS</li> </ul>"},{"location":"transportes/esp-now/","title":"\ud83d\udce1 ESP-NOW","text":"<p>Wireless MIDI de ultra-baixa lat\u00eancia entre ESP32 via protocolo propriet\u00e1rio Espressif. Sem router, sem handshake, sem pareamento \u2014 funciona em qualquer ESP32.</p>"},{"location":"transportes/esp-now/#caracteristicas","title":"Caracter\u00edsticas","text":"Aspecto Detalhe Protocolo ESP-NOW (Espressif) F\u00edsico R\u00e1dio WiFi 2,4 GHz (P2P, sem router) Lat\u00eancia 1\u20135 ms Alcance ~200 m (linha de vis\u00e3o) Modo Broadcast ou Unicast Chips Qualquer ESP32, S2, S3, C3, C6 Chips sem ESP-NOW ESP32-P4 (sem r\u00e1dio WiFi)"},{"location":"transportes/esp-now/#como-funciona","title":"Como Funciona","text":"<pre><code>graph LR\n    subgraph STAGE[\"\ud83c\udfb8 Palco\"]\n        ESP1[\"ESP32 #1\\n(Guitarrista)\"]\n        ESP2[\"ESP32 #2\\n(Tecladista)\"]\n        ESP3[\"ESP32 #3\\n(Baixista)\"]\n        HUB[\"ESP32 Hub\\n(Central)\"]\n    end\n\n    subgraph FOH[\"\ud83c\udf9b\ufe0f FOH\"]\n        PC[\"Computador\\n(DAW / USB)\"]\n    end\n\n    ESP1 &lt;--&gt;|\"ESP-NOW\\n1-5 ms\"| HUB\n    ESP2 &lt;--&gt;|\"ESP-NOW\\n1-5 ms\"| HUB\n    ESP3 &lt;--&gt;|\"ESP-NOW\\n1-5 ms\"| HUB\n    HUB --&gt;|\"USB Device\\nou RTP-MIDI\"| PC\n\n    style HUB fill:#3F51B5,color:#fff\n    style STAGE fill:#1A237E,color:#fff,stroke:#283593\n    style FOH fill:#1B5E20,color:#fff,stroke:#2E7D32</code></pre> <p>O ESP-NOW usa o r\u00e1dio WiFi em modo peer-to-peer, sem necessidade de access point. M\u00faltiplos ESP32 podem se comunicar em broadcast (todos recebem de todos) ou unicast (ponto a ponto).</p>"},{"location":"transportes/esp-now/#codigo-modo-broadcast","title":"C\u00f3digo \u2014 Modo Broadcast","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/ESPNowConnection.h\"\n\nESPNowConnection espNow;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    // Canal WiFi deve ser o mesmo em todos os ESP32 do grupo\n    espNow.begin(/*channel=*/11);\n\n    midiHandler.addTransport(&amp;espNow);\n    midiHandler.begin();\n\n    Serial.println(\"ESP-NOW MIDI pronto (broadcast)\");\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"[ESP-NOW] %s %s vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.velocity);\n    }\n\n    // Enviar nota a cada 2 segundos (exemplo)\n    static unsigned long last = 0;\n    if (millis() - last &gt; 2000) {\n        midiHandler.sendNoteOn(1, 60, 100);\n        delay(200);\n        midiHandler.sendNoteOff(1, 60, 0);\n        last = millis();\n    }\n}\n</code></pre>"},{"location":"transportes/esp-now/#codigo-modo-unicast-par-especifico","title":"C\u00f3digo \u2014 Modo Unicast (par espec\u00edfico)","text":"<pre><code>#include \"src/ESPNowConnection.h\"\n\nESPNowConnection espNow;\n\n// MAC do ESP32 de destino (ver Serial.println(WiFi.macAddress()))\nuint8_t peerMAC[] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};\n\nvoid setup() {\n    espNow.begin(11);\n\n    // Adicionar peer espec\u00edfico (unicast)\n    espNow.addPeer(peerMAC);\n\n    midiHandler.addTransport(&amp;espNow);\n    midiHandler.begin();\n}\n</code></pre>"},{"location":"transportes/esp-now/#descobrir-o-mac-de-um-esp32","title":"Descobrir o MAC de um ESP32","text":"<pre><code>void setup() {\n    Serial.begin(115200);\n    WiFi.mode(WIFI_STA);\n    Serial.printf(\"MAC: %s\\n\", WiFi.macAddress().c_str());\n    // Exemplo: \"AA:BB:CC:DD:EE:FF\"\n}\n</code></pre>"},{"location":"transportes/esp-now/#jam-colaborativo-3-esp32","title":"Jam Colaborativo \u2014 3 ESP32","text":"<pre><code>sequenceDiagram\n    participant ESP1 as ESP32 #1 (Teclado USB)\n    participant ESP2 as ESP32 #2 (Pad)\n    participant ESP3 as ESP32 #3 (Display)\n\n    Note over ESP1,ESP3: Todos no mesmo canal ESP-NOW (11)\n    Note over ESP1,ESP3: Broadcast \u2014 todos recebem de todos\n\n    ESP1-&gt;&gt;ESP2: NoteOn C4 [ESP-NOW]\n    ESP1-&gt;&gt;ESP3: NoteOn C4 [ESP-NOW]\n    ESP2-&gt;&gt;ESP1: NoteOn kick drum [ESP-NOW]\n    ESP2-&gt;&gt;ESP3: NoteOn kick drum [ESP-NOW]\n\n    Note over ESP3: Display mostra\\ntodas as notas do jam</code></pre>"},{"location":"transportes/esp-now/#esp-now-usb-host-ble","title":"ESP-NOW + USB Host + BLE","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/ESPNowConnection.h\"\n\nESPNowConnection espNow;\n\nvoid setup() {\n    // ESP-NOW\n    espNow.begin(11);\n    midiHandler.addTransport(&amp;espNow);\n\n    // USB Host + BLE iniciados automaticamente\n    MIDIHandlerConfig cfg;\n    cfg.bleName = \"Jam Node\";\n    midiHandler.begin(cfg);\n\n    // Agora teclado USB + BLE + ESP-NOW est\u00e3o todos ativos!\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    // Evento de qualquer transporte\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        // Automaticamente repassado para todos os outros!\n    }\n}\n</code></pre>"},{"location":"transportes/esp-now/#consideracoes-de-canal-wifi","title":"Considera\u00e7\u00f5es de Canal WiFi","text":"<p>Canal WiFi</p> <p>O ESP-NOW e o WiFi (esta\u00e7\u00e3o) precisam usar o mesmo canal. Se o ESP32 estiver conectado a um router WiFi, o ESP-NOW usar\u00e1 o canal do router automaticamente. Se n\u00e3o houver WiFi, voc\u00ea especifica o canal em <code>espNow.begin(channel)</code>.</p> <pre><code>// Se usando ESP-NOW junto com WiFi (para RTP-MIDI):\nWiFi.begin(\"ssid\", \"password\");\nwhile (WiFi.status() != WL_CONNECTED) delay(500);\n// O canal \u00e9 determinado pelo router \u2014 N\u00c3O passe o canal para begin()\nespNow.begin();  // usa canal atual do WiFi\n\n// Se usando apenas ESP-NOW (sem WiFi):\nespNow.begin(11);  // canal fixo 11 (1-13)\n</code></pre>"},{"location":"transportes/esp-now/#exemplos","title":"Exemplos","text":"Exemplo Descri\u00e7\u00e3o <code>T-Display-S3-ESP-NOW-Jam</code> Jam colaborativo com display <code>ESP-NOW-MIDI</code> ESP-NOW MIDI b\u00e1sico"},{"location":"transportes/esp-now/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>BLE MIDI \u2192 \u2014 alcance ~30 m mas compat\u00edvel com iOS</li> <li>RTP-MIDI \u2192 \u2014 usar WiFi com router para maior alcance</li> <li>Exemplos ESP-NOW \u2192 \u2014 sketch completo do jam</li> </ul>"},{"location":"transportes/ethernet-midi/","title":"\ud83d\udd17 Ethernet MIDI","text":"<p>Mesmo protocolo RTP-MIDI / AppleMIDI do WiFi, mas sobre Ethernet cabeada. Lat\u00eancia mais baixa e consistente \u2014 ideal para est\u00fadios e instala\u00e7\u00f5es com rede gerenciada.</p>"},{"location":"transportes/ethernet-midi/#caracteristicas","title":"Caracter\u00edsticas","text":"Aspecto Detalhe Protocolo AppleMIDI / RTP-MIDI (RFC 6295) F\u00edsico Ethernet cabeada (RJ-45) Lat\u00eancia 2\u201310 ms (mais est\u00e1vel que WiFi) Hardware W5500 SPI Ethernet ou ESP32-P4 (MAC nativo) Requer <code>lathoub/Arduino-AppleMIDI-Library</code> + <code>arduino-libraries/Ethernet</code>"},{"location":"transportes/ethernet-midi/#hardware","title":"Hardware","text":""},{"location":"transportes/ethernet-midi/#opcao-1-modulo-w5500-spi-qualquer-esp32","title":"Op\u00e7\u00e3o 1: M\u00f3dulo W5500 SPI (qualquer ESP32)","text":"<p>O W5500 \u00e9 um chip Ethernet completo com interface SPI. Funciona em qualquer ESP32.</p> <pre><code>M\u00f3dulo W5500\n  MOSI  \u2192 ESP32 GPIO 23\n  MISO  \u2192 ESP32 GPIO 19\n  SCK   \u2192 ESP32 GPIO 18\n  CS    \u2192 ESP32 GPIO 5\n  RST   \u2192 ESP32 GPIO 4\n  VCC   \u2192 3.3V\n  GND   \u2192 GND\n</code></pre>"},{"location":"transportes/ethernet-midi/#opcao-2-esp32-p4-mac-ethernet-nativo","title":"Op\u00e7\u00e3o 2: ESP32-P4 (MAC Ethernet nativo)","text":"<p>O ESP32-P4 tem um controlador Ethernet MAC nativo (IEEE 802.3). Requer apenas um PHY externo (ex: LAN8720):</p> <pre><code>#if ESP32_HOST_MIDI_HAS_ETH_MAC\n    // MAC nativo dispon\u00edvel \u2014 configure o PHY no sdkconfig\n#endif\n</code></pre>"},{"location":"transportes/ethernet-midi/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;SPI.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/EthernetMIDIConnection.h\"  // Requer AppleMIDI + Ethernet\n\nEthernetMIDIConnection ethMIDI;\nstatic const uint8_t MAC[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };\n\nvoid setup() {\n    Serial.begin(115200);\n\n    // Registrar antes de begin()\n    midiHandler.addTransport(&amp;ethMIDI);\n\n    // DHCP autom\u00e1tico\n    ethMIDI.begin(MAC);  // (1)\n\n    // Ou IP est\u00e1tico:\n    // ethMIDI.begin(MAC, IPAddress(192, 168, 1, 100));  // (2)\n\n    midiHandler.begin();\n\n    Serial.printf(\"Ethernet MIDI: %s\\n\",\n        Ethernet.localIP().toString().c_str());\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"[ETH] %s %s vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.velocity);\n    }\n}\n</code></pre> <p>Anota\u00e7\u00f5es:</p> <ol> <li>DHCP: O m\u00f3dulo W5500 obt\u00e9m IP automaticamente via DHCP</li> <li>IP est\u00e1tico: Passe um <code>IPAddress</code> como segundo argumento</li> </ol>"},{"location":"transportes/ethernet-midi/#conectar-no-macos","title":"Conectar no macOS","text":"<p>mDNS n\u00e3o dispon\u00edvel no Ethernet com W5500</p> <p>A biblioteca Ethernet padr\u00e3o n\u00e3o suporta mDNS/Bonjour. Voc\u00ea deve configurar o IP manualmente no Audio MIDI Setup.</p>"},{"location":"transportes/ethernet-midi/#passo-a-passo","title":"Passo a passo","text":"<ol> <li>Abra Audio MIDI Setup \u2192 Window \u2192 Show MIDI Studio</li> <li>Clique em Network</li> <li>Em \"My Sessions\", clique em + para criar uma sess\u00e3o</li> <li>Em \"Directory\" \u2192 + \u2192 Digite o IP do ESP32 e porta 5004</li> <li>Selecione a sess\u00e3o e clique em Connect</li> </ol>"},{"location":"transportes/ethernet-midi/#wifi-vs-ethernet-comparacao","title":"WiFi vs. Ethernet \u2014 Compara\u00e7\u00e3o","text":"Aspecto WiFi (RTP-MIDI) Ethernet (W5500) Cabo Sem fio RJ-45 Lat\u00eancia m\u00e9dia 5\u201320 ms 2\u201310 ms Jitter Moderado Muito baixo mDNS / Auto-discovery \u2705 \u274c (IP manual) Chips compat\u00edveis Qualquer com WiFi Qualquer ESP32 Ideal para Uso casual / palco Est\u00fadio / instala\u00e7\u00e3o"},{"location":"transportes/ethernet-midi/#exemplo-pratico-rack-de-estudio","title":"Exemplo Pr\u00e1tico \u2014 Rack de Est\u00fadio","text":"<pre><code>Sintetizador DIN-5 \u2500\u2500\u25ba ESP32 (UART) \u2500\u2500\u25ba Ethernet W5500 \u2500\u2500\u25ba Switch \u2500\u2500\u25ba macOS Logic Pro\n</code></pre> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/UARTConnection.h\"\n#include \"src/EthernetMIDIConnection.h\"\n\nUARTConnection uartMIDI;\nEthernetMIDIConnection ethMIDI;\nconst uint8_t MAC[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };\n\nvoid setup() {\n    uartMIDI.begin(Serial1, 16, 17);\n    ethMIDI.begin(MAC, IPAddress(192, 168, 1, 50));\n\n    midiHandler.addTransport(&amp;uartMIDI);\n    midiHandler.addTransport(&amp;ethMIDI);\n    midiHandler.begin();\n    // Bridge autom\u00e1tico DIN-5 \u2194 Ethernet!\n}\n\nvoid loop() {\n    midiHandler.task();\n}\n</code></pre>"},{"location":"transportes/ethernet-midi/#exemplos","title":"Exemplos","text":"Exemplo Descri\u00e7\u00e3o <code>Ethernet-MIDI</code> Ethernet MIDI b\u00e1sico com W5500"},{"location":"transportes/ethernet-midi/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>RTP-MIDI WiFi \u2192 \u2014 alternativa sem fio com mDNS</li> <li>UART / DIN-5 \u2192 \u2014 adicionar porta DIN-5 ao rack</li> <li>Hardware Suportado \u2192 \u2014 ESP32-P4 com Ethernet nativo</li> </ul>"},{"location":"transportes/midi2-udp/","title":"\ud83d\ude80 MIDI 2.0 / UMP sobre UDP","text":"<p>MIDI 2.0 implementado end-to-end com <code>MIDI2UDPConnection</code> \u2014 um protocolo UDP customizado de 12 bytes carregando Universal MIDI Packets (UMP) entre ESP32. Comunique-se com resolu\u00e7\u00e3o completa MIDI 2.0: velocidade de 16 bits, CC de 32 bits, Pitch Bend de 32 bits.</p>"},{"location":"transportes/midi2-udp/#midi-10-vs-midi-20","title":"MIDI 1.0 vs. MIDI 2.0","text":"Aspecto MIDI 1.0 MIDI 2.0 Velocidade 7 bits (0\u2013127) 16 bits (0\u201365535) Control Change 7 bits (0\u2013127) 32 bits (0\u20134 bilh\u00f5es) Pitch Bend 14 bits (0\u201316383) 32 bits Retrocompat\u00edvel \u2014 \u2705 (downscaling autom\u00e1tico) Protocolo Bytes simples UMP (Universal MIDI Packet)"},{"location":"transportes/midi2-udp/#protocolo-midi2udp-12-bytes","title":"Protocolo MIDI2UDP (12 bytes)","text":"<pre><code>Byte  0\u20133:  Magic \"UMP2\" (0x55 0x4D 0x50 0x32)\nByte  4\u20137:  UMP Word 0 (big-endian uint32)\nByte  8\u201311: UMP Word 1 (big-endian uint32, = 0x00000000 para pacotes 32-bit)\n</code></pre> <p>O Word 0 cont\u00e9m o header UMP: <pre><code>Bits 31-28: Message Type (0x4 = MIDI 2.0 Channel Voice)\nBits 27-24: Group\nBits 23-20: Status/Opcode\nBits 19-16: Channel (0-15)\nBits 15-8:  Note number (para NoteOn/NoteOff)\nBits 7-0:   Attribute Type\n</code></pre></p>"},{"location":"transportes/midi2-udp/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/MIDI2UDPConnection.h\"  // Inclui MIDI2Support automaticamente\n\nMIDI2UDPConnection midi2udp;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    WiFi.begin(\"SeuSSID\", \"SuaSenha\");\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.printf(\"\\nIP: %s\\n\", WiFi.localIP().toString().c_str());\n\n    // Escuta na porta 5006\n    // Envia para 192.168.1.20 na porta 5006 (o outro ESP32)\n    midi2udp.begin(5006, IPAddress(192, 168, 1, 20), 5006);\n\n    midiHandler.addTransport(&amp;midi2udp);\n    midiHandler.begin();\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        // ev cont\u00e9m os valores MIDI 1.0 (downscaled)\n        Serial.printf(\"[MIDI2] %s %s  vel7=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.velocity);\n\n        // Acessar valores MIDI 2.0 completos:\n        const UMPResult&amp; r = midi2udp.lastResult();\n        if (r.valid) {\n            Serial.printf(\"        vel16=%u  (%.1f%%)\\n\",\n                r.velocity16,\n                r.velocity16 / 65535.0f * 100.0f);\n        }\n    }\n}\n</code></pre>"},{"location":"transportes/midi2-udp/#estrutura-umpresult","title":"Estrutura UMPResult","text":"<pre><code>struct UMPResult {\n    bool valid;          // Pacote v\u00e1lido?\n    bool isMIDI2;        // True = MIDI 2.0 (64-bit), False = MIDI 1.0 (32-bit)\n    uint8_t msgType;     // Tipo de mensagem UMP\n    uint8_t channel;     // Canal MIDI (0-15)\n    uint8_t note;        // Nota MIDI (0-127)\n    uint16_t velocity16; // Velocidade 16-bit (MIDI 2.0)\n    uint32_t value;      // Valor 32-bit (CC, Pitch Bend)\n    uint8_t midi1[3];    // Bytes MIDI 1.0 equivalentes (downscaled)\n};\n</code></pre>"},{"location":"transportes/midi2-udp/#escalamento-de-valores","title":"Escalamento de Valores","text":"<pre><code>flowchart LR\n    subgraph MIDI1[\"MIDI 1.0\"]\n        VEL7[\"Velocidade\\n7 bits\\n0\u2013127\"]\n        CC7[\"CC\\n7 bits\\n0\u2013127\"]\n        PB14[\"Pitch Bend\\n14 bits\\n0\u201316383\"]\n    end\n\n    subgraph MIDI2[\"MIDI 2.0\"]\n        VEL16[\"Velocidade\\n16 bits\\n0\u201365535\"]\n        CC32[\"CC\\n32 bits\\n0\u20134.29 bilh\u00f5es\"]\n        PB32[\"Pitch Bend\\n32 bits\"]\n    end\n\n    VEL7 &lt;--&gt;|\"MIDI2Scaler\\nscale7to16 / scale16to7\"| VEL16\n    CC7 &lt;--&gt;|\"MIDI2Scaler\\nscale7to32 / scale32to7\"| CC32\n    PB14 &lt;--&gt;|\"MIDI2Scaler\\nscale14to32 / scale32to14\"| PB32\n\n    style MIDI1 fill:#37474F,color:#fff\n    style MIDI2 fill:#3F51B5,color:#fff</code></pre>"},{"location":"transportes/midi2-udp/#api-de-escalamento-midi2supporth","title":"API de Escalamento (MIDI2Support.h)","text":"<pre><code>#include \"src/MIDI2Support.h\"\n\n// MIDI 1.0 \u2192 MIDI 2.0\nuint16_t vel16 = MIDI2Scaler::scale7to16(vel7);    // 7\u219216 bits\nuint32_t cc32  = MIDI2Scaler::scale7to32(cc7);     // 7\u219232 bits\nuint32_t pb32  = MIDI2Scaler::scale14to32(pb14);   // 14\u219232 bits\n\n// MIDI 2.0 \u2192 MIDI 1.0\nuint8_t  vel7  = MIDI2Scaler::scale16to7(vel16);   // 16\u21927 bits\nuint8_t  cc7   = MIDI2Scaler::scale32to7(cc32);    // 32\u21927 bits\nuint16_t pb14  = MIDI2Scaler::scale32to14(pb32);   // 32\u219214 bits\n</code></pre>"},{"location":"transportes/midi2-udp/#builder-e-parser-ump","title":"Builder e Parser UMP","text":"<pre><code>#include \"src/MIDI2Support.h\"\n\n// Construir pacote UMP\nuint16_t vel16 = MIDI2Scaler::scale7to16(100);         // 7-bit \u2192 16-bit\nUMPWord64 pkt  = UMPBuilder::noteOn(0, 0, 60, vel16);  // group=0, ch=0, note=60\n\n// Parsear pacote UMP\nUMPResult r = UMPParser::parseMIDI2(pkt);\nSerial.printf(\"Note=%d  Vel16=%u\\n\", r.note, r.velocity16);\n</code></pre>"},{"location":"transportes/midi2-udp/#tipos-de-mensagem-ump","title":"Tipos de Mensagem UMP","text":"Opcode Mensagem <code>0x9</code> NoteOn <code>0x8</code> NoteOff <code>0xB</code> Control Change <code>0xE</code> Pitch Bend <code>0xC</code> Program Change <code>0xD</code> Channel Pressure <code>0xA</code> Poly Pressure"},{"location":"transportes/midi2-udp/#experimento-com-dois-esp32","title":"Experimento com Dois ESP32","text":"<p>Conecte dois ESP32-S3 na mesma rede WiFi. O ESP32-A toca notas no teclado USB, o ESP32-B recebe com resolu\u00e7\u00e3o MIDI 2.0 completa:</p> <pre><code>ESP32-A (teclado USB) \u2192 MIDIHandler \u2192 MIDI2UDP \u2192 WiFi \u2192 ESP32-B (display)\n                                                           \u2193\n                                               vel16, cc32, pb32\n</code></pre> T-Display-S3-MIDI2-UDP \u2014 barra de velocidade 16-bit mostrando resolu\u00e7\u00e3o MIDI 2.0"},{"location":"transportes/midi2-udp/#exemplos","title":"Exemplos","text":"Exemplo Descri\u00e7\u00e3o <code>T-Display-S3-MIDI2-UDP</code> Dois ESP32 com display de vel. 16-bit"},{"location":"transportes/midi2-udp/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>MIDI 2.0 / UMP Deep Dive \u2192 \u2014 especifica\u00e7\u00e3o completa UMP</li> <li>OSC \u2192 \u2014 alternativa para Max/MSP e Pure Data</li> <li>Exemplos MIDI 2.0 \u2192 \u2014 sketch completo com display</li> </ul>"},{"location":"transportes/osc/","title":"\ud83c\udfa8 OSC (Open Sound Control)","text":"<p>Bridge bidirecional OSC \u2194 MIDI sobre WiFi UDP. Recebe mensagens OSC do Max/MSP, Pure Data, SuperCollider e TouchOSC e converte em eventos MIDI \u2014 e vice-versa.</p>"},{"location":"transportes/osc/#caracteristicas","title":"Caracter\u00edsticas","text":"Aspecto Detalhe Protocolo OSC 1.0 sobre UDP Lat\u00eancia 5\u201315 ms Bidirecional \u2705 (recebe e envia) Plataformas Max/MSP, Pure Data, SuperCollider, TouchOSC, Pd, Processing Requer WiFi + <code>CNMAT/OSC library</code>"},{"location":"transportes/osc/#instalar-a-biblioteca-osc","title":"Instalar a Biblioteca OSC","text":"<pre><code>Arduino IDE \u2192 Sketch \u2192 Include Library \u2192 Manage Libraries\n\u2192 Pesquisar: \"OSC\"\n\u2192 Instalar: OSC by Adrian Freed, Yotam Mann (CNMAT)\n</code></pre>"},{"location":"transportes/osc/#mapa-de-enderecos-osc","title":"Mapa de Endere\u00e7os OSC","text":"<p>A biblioteca mapeia automaticamente entre OSC e MIDI:</p> Endere\u00e7o OSC Argumentos Mensagem MIDI <code>/midi/noteon</code> channel note velocity NoteOn <code>/midi/noteoff</code> channel note velocity NoteOff <code>/midi/cc</code> channel controller value Control Change <code>/midi/pc</code> channel program Program Change <code>/midi/pitchbend</code> channel bend Pitch Bend (-8192 a +8191) <code>/midi/aftertouch</code> channel pressure Channel Pressure"},{"location":"transportes/osc/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/OSCConnection.h\"  // Requer CNMAT/OSC\n\nOSCConnection oscMIDI;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    WiFi.begin(\"SeuSSID\", \"SuaSenha\");\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.printf(\"\\nIP: %s\\n\", WiFi.localIP().toString().c_str());\n\n    // Porta local: 8000  |  IP remoto: 192.168.1.100  |  Porta remota: 9000\n    oscMIDI.begin(8000, IPAddress(192, 168, 1, 100), 9000);\n\n    midiHandler.addTransport(&amp;oscMIDI);\n    midiHandler.begin();\n\n    Serial.println(\"OSC MIDI pronto\");\n    Serial.printf(\"Escutando OSC em: %s:8000\\n\", WiFi.localIP().toString().c_str());\n    Serial.println(\"Enviando OSC para: 192.168.1.100:9000\");\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"[OSC\u2192MIDI] %s %s vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.velocity);\n    }\n}\n</code></pre>"},{"location":"transportes/osc/#integracao-com-maxmsp","title":"Integra\u00e7\u00e3o com Max/MSP","text":"<pre><code>flowchart LR\n    subgraph MAX[\"\ud83d\udda5\ufe0f Max/MSP (computador)\"]\n        MAXPATCH[\"patch Max\\n[udpsend] \u2192 192.168.1.X:8000\\n[udpreceive 9000]\"]\n    end\n\n    subgraph ESP[\"\ud83d\udce1 ESP32\"]\n        OSCCONN[\"OSCConnection\\nescuta :8000\\nenvia para :9000\"]\n        HANDLER[\"MIDIHandler\"]\n        USB[\"Teclado USB\"]\n    end\n\n    MAXPATCH &lt;--&gt;|\"UDP WiFi\\n/midi/noteon...\"| OSCCONN\n    OSCCONN &lt;--&gt; HANDLER\n    USB --&gt; HANDLER\n\n    style ESP fill:#3F51B5,color:#fff,stroke:#283593\n    style MAX fill:#1B5E20,color:#fff,stroke:#2E7D32</code></pre>"},{"location":"transportes/osc/#patch-maxmsp-basico","title":"Patch Max/MSP b\u00e1sico","text":"<pre><code>[udpreceive 9000]\n        |\n    [OSC-route /midi/noteon]\n        |\n    [unpack i i i]   \u2190 channel note velocity\n        |           |           |\n    [route]        [route]     [route]\n</code></pre> <p>Para enviar do Max para o ESP32: <pre><code>[pack i i i]  \u2190 channel note velocity\n     |\n[OSC-format /midi/noteon]\n     |\n[udpsend 192.168.1.X 8000]  \u2190 IP do ESP32\n</code></pre></p>"},{"location":"transportes/osc/#integracao-com-pure-data-pd","title":"Integra\u00e7\u00e3o com Pure Data (Pd)","text":""},{"location":"transportes/osc/#receber-midi-no-pd-vindo-do-esp32","title":"Receber MIDI no Pd (vindo do ESP32)","text":"<pre><code>[udpreceive 9000]\n       |\n [oscparse]\n       |\n[route /midi/noteon /midi/noteoff /midi/cc]\n</code></pre>"},{"location":"transportes/osc/#enviar-midi-do-pd-para-o-esp32","title":"Enviar MIDI do Pd para o ESP32","text":"<pre><code>[pack f f f]    \u2190 channel note velocity\n      |\n[oscformat /midi/noteon]\n      |\n[udpsend]\n[connect 192.168.1.X 8000]\n</code></pre>"},{"location":"transportes/osc/#touchosc","title":"TouchOSC","text":"<p>Configure o TouchOSC para enviar para o IP do ESP32 na porta 8000, e receber na porta 9000.</p> <p>Cada bot\u00e3o/slider no TouchOSC pode enviar: <pre><code>/midi/noteon   1 60 127   (toca C4 no canal 1 com vel 127)\n/midi/cc       1 74 64    (Cutoff CC#74 = 50% no canal 1)\n</code></pre></p>"},{"location":"transportes/osc/#bridge-osc-usb-teclado-fisico-maxmsp","title":"Bridge OSC \u2192 USB (teclado f\u00edsico \u2192 Max/MSP)","text":"<p>O caso de uso mais pr\u00e1tico: teclado USB conectado ao ESP32, Max/MSP recebe via OSC.</p> <pre><code>#include &lt;WiFi.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/OSCConnection.h\"\n// Tools &gt; USB Mode \u2192 \"USB Host\"\n\nOSCConnection oscMIDI;\n\nvoid setup() {\n    WiFi.begin(\"ssid\", \"password\");\n    while (WiFi.status() != WL_CONNECTED) delay(500);\n\n    // ESP32 recebe MIDI do teclado USB\n    // Max/MSP est\u00e1 em 192.168.1.50 escutando na porta 9000\n    oscMIDI.begin(8000, IPAddress(192, 168, 1, 50), 9000);\n\n    midiHandler.addTransport(&amp;oscMIDI);\n    midiHandler.begin();\n    // Cada nota do teclado USB \u00e9 enviada como OSC para o Max!\n}\n\nvoid loop() { midiHandler.task(); }\n</code></pre>"},{"location":"transportes/osc/#exemplos","title":"Exemplos","text":"Exemplo Descri\u00e7\u00e3o <code>T-Display-S3-OSC</code> Bridge OSC com display WiFi status"},{"location":"transportes/osc/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>RTP-MIDI \u2192 \u2014 alternativa para DAWs com suporte AppleMIDI</li> <li>MIDI 2.0 UDP \u2192 \u2014 protocolo UDP customizado com alta resolu\u00e7\u00e3o</li> <li>Exemplos OSC \u2192 \u2014 sketch completo com display</li> </ul>"},{"location":"transportes/rtp-midi/","title":"\ud83c\udf10 RTP-MIDI (WiFi)","text":"<p>Implementa Apple MIDI (RTP-MIDI, RFC 6295) sobre WiFi UDP. O ESP32 aparece automaticamente em Audio MIDI Setup \u2192 Network no macOS e iOS via mDNS Bonjour \u2014 nenhuma configura\u00e7\u00e3o manual de IP.</p>"},{"location":"transportes/rtp-midi/#caracteristicas","title":"Caracter\u00edsticas","text":"Aspecto Detalhe Protocolo AppleMIDI / RTP-MIDI (RFC 6295) Descoberta mDNS / Bonjour autom\u00e1tico Lat\u00eancia 5\u201320 ms Plataformas macOS, iOS, Logic Pro, GarageBand, Ableton Requer WiFi conectado + <code>lathoub/Arduino-AppleMIDI-Library v3.x</code>"},{"location":"transportes/rtp-midi/#instalar-a-biblioteca","title":"Instalar a Biblioteca","text":"<pre><code>Arduino IDE \u2192 Sketch \u2192 Include Library \u2192 Manage Libraries\n\u2192 Pesquisar: \"AppleMIDI\"\n\u2192 Instalar: Arduino-AppleMIDI-Library by lathoub (v3.x)\n</code></pre>"},{"location":"transportes/rtp-midi/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/RTPMIDIConnection.h\"  // Requer AppleMIDI-Library\n\nRTPMIDIConnection rtpMIDI;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    // Conectar ao WiFi\n    WiFi.begin(\"SeuSSID\", \"SuaSenha\");\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.printf(\"\\nWiFi: %s\\n\", WiFi.localIP().toString().c_str());\n\n    // Iniciar RTP-MIDI (aparece em macOS Audio MIDI Setup)\n    rtpMIDI.begin(\"Meu ESP32\");  // Nome da sess\u00e3o\n\n    midiHandler.addTransport(&amp;rtpMIDI);\n    midiHandler.begin();\n\n    Serial.println(\"RTP-MIDI pronto \u2014 abra 'Audio MIDI Setup' no Mac\");\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"[RTP] %s %s vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.velocity);\n    }\n}\n</code></pre>"},{"location":"transportes/rtp-midi/#conectar-no-macos","title":"Conectar no macOS","text":"<pre><code>sequenceDiagram\n    participant ESP32 as ESP32 (RTP-MIDI)\n    participant MDNS as mDNS/Bonjour\n    participant MAC as macOS (Audio MIDI Setup)\n\n    ESP32-&gt;&gt;ESP32: WiFi.begin() \u2014 conecta \u00e0 rede\n    ESP32-&gt;&gt;MDNS: Anuncia \"_apple-midi._udp\"&lt;br/&gt;Nome: \"Meu ESP32\"\n    MAC-&gt;&gt;MDNS: Scan da rede local\n    MDNS--&gt;&gt;MAC: \"Meu ESP32\" dispon\u00edvel\n    MAC-&gt;&gt;MAC: Aparece em Network MIDI\n\n    Note over MAC: Audio MIDI Setup \u2192 Window \u2192&lt;br/&gt;Show MIDI Studio \u2192 Network&lt;br/&gt;\u2192 \"Meu ESP32\" (online)\n\n    MAC-&gt;&gt;ESP32: Connect (RTP-MIDI handshake)\n    ESP32--&gt;&gt;MAC: Session established\n\n    loop Sess\u00e3o ativa\n        MAC-&gt;&gt;ESP32: MIDI data (Logic, GarageBand...)\n        ESP32-&gt;&gt;MAC: MIDI data (teclado USB, BLE...)\n    end</code></pre>"},{"location":"transportes/rtp-midi/#passo-a-passo-no-macos","title":"Passo a passo no macOS","text":"<ol> <li>Abra Audio MIDI Setup (<code>/Applications/Utilities/</code>)</li> <li>Menu Window \u2192 Show MIDI Studio</li> <li>Clique em Network (\u00edcone globo no topo)</li> <li>No painel esquerdo \"Directory\", o ESP32 aparece com o nome configurado</li> <li>Selecione e clique em Connect</li> <li>A porta MIDI \"Meu ESP32\" aparece em todos os DAWs automaticamente</li> </ol>"},{"location":"transportes/rtp-midi/#conectar-no-ios","title":"Conectar no iOS","text":"<ol> <li>Abra GarageBand (ou qualquer app CoreMIDI)</li> <li>Settings \u2192 Advanced \u2192 MIDI</li> <li>O ESP32 aparece na lista de sess\u00f5es de rede</li> </ol>"},{"location":"transportes/rtp-midi/#sequenciador-com-rtp-midi","title":"Sequenciador com RTP-MIDI","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/RTPMIDIConnection.h\"\n\nRTPMIDIConnection rtpMIDI;\n\nconst uint8_t SEQ[] = {60, 64, 67, 72};  // C4, E4, G4, C5\nint step = 0;\nunsigned long nextNote = 0;\nconst int BPM = 120;\nconst int NOTE_MS = 60000 / BPM / 2;  // colcheia\n\nvoid setup() {\n    WiFi.begin(\"ssid\", \"password\");\n    while (WiFi.status() != WL_CONNECTED) delay(500);\n\n    rtpMIDI.begin(\"Sequenciador ESP32\");\n    midiHandler.addTransport(&amp;rtpMIDI);\n    midiHandler.begin();\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    unsigned long now = millis();\n    if (now &gt;= nextNote) {\n        // Desliga nota anterior\n        midiHandler.sendNoteOff(1, SEQ[(step - 1 + 4) % 4], 0);\n        // Liga pr\u00f3xima nota\n        midiHandler.sendNoteOn(1, SEQ[step], 100);\n        step = (step + 1) % 4;\n        nextNote = now + NOTE_MS;\n    }\n}\n</code></pre>"},{"location":"transportes/rtp-midi/#galeria","title":"Galeria","text":"RTP-MIDI no Audio MIDI Setup do macOS Sess\u00e3o RTP-MIDI conectada"},{"location":"transportes/rtp-midi/#latencia-e-jitter","title":"Lat\u00eancia e Jitter","text":"<p>O RTP-MIDI inclui timestamps e mecanismos de sincroniza\u00e7\u00e3o (clock sync) para compensar o jitter do WiFi. Na pr\u00e1tica, com boa rede WiFi:</p> <ul> <li>Casa / est\u00fadio (rede limpa): 5\u201315 ms, jitter &lt; 3 ms</li> <li>Rede congestionada: 15\u201330 ms, jitter vari\u00e1vel</li> <li>5 GHz vs 2,4 GHz: 5 GHz \u00e9 mais est\u00e1vel para MIDI</li> </ul> <p>Melhorar lat\u00eancia</p> <ul> <li>Use rede WiFi dedicada (sem outros dispositivos de streaming)</li> <li>Prefira banda 5 GHz</li> <li>Posicione o roteador pr\u00f3ximo ao ESP32</li> </ul>"},{"location":"transportes/rtp-midi/#exemplos","title":"Exemplos","text":"Exemplo Descri\u00e7\u00e3o <code>RTP-MIDI-WiFi</code> Sequenciador com step display no T-Display-S3"},{"location":"transportes/rtp-midi/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Ethernet MIDI \u2192 \u2014 mesma lat\u00eancia mais consistente com cabo</li> <li>OSC \u2192 \u2014 alternativa para Max/MSP e Pure Data</li> <li>Exemplos RTP-MIDI \u2192 \u2014 sketch completo com display</li> </ul>"},{"location":"transportes/uart-din5/","title":"\ud83c\udfb9 UART / DIN-5","text":"<p>MIDI serial padr\u00e3o (31250 baud, 8N1) para conectar hardware vintage \u2014 sintetizadores, caixas de ritmo, mixers e sequenciadores com conector DIN-5. Funciona em qualquer ESP32.</p>"},{"location":"transportes/uart-din5/#protocolo-midi-serial","title":"Protocolo MIDI Serial","text":"<p>O MIDI original (1983) usa comunica\u00e7\u00e3o serial ass\u00edncrona:</p> Par\u00e2metro Valor Baud rate 31250 bps (n\u00e3o \u00e9 31.25 kHz, \u00e9 31250 bps) Formato 8 bits, sem paridade, 1 stop bit (8N1) N\u00edvel el\u00e9trico 5V TTL com isola\u00e7\u00e3o \u00f3ptica (opto) Conector DIN-5 f\u00eamea (5 pinos, mas usa apenas 3: GND, TX, RX)"},{"location":"transportes/uart-din5/#pinagem-do-conector-din-5","title":"Pinagem do Conector DIN-5","text":"<pre><code>        DIN-5 (vista frontal do conector f\u00eamea)\n             ___\n           /     \\\n          / 4   5 \\\n         |  1   2  |\n          \\   3   /\n           \\_____/\n\nDIN-5 pino 2 = GND (blindagem)\nDIN-5 pino 4 = MIDI OUT (+5V fonte de corrente)\nDIN-5 pino 5 = MIDI IN (dados)\n</code></pre>"},{"location":"transportes/uart-din5/#circuito-de-hardware","title":"Circuito de Hardware","text":""},{"location":"transportes/uart-din5/#midi-out-esp32-sintetizador","title":"MIDI OUT (ESP32 \u2192 Sintetizador)","text":"<pre><code>ESP32 GPIO TX \u2500\u2500\u2500 220\u03a9 \u2500\u2500\u25ba DIN-5 pino 5 (dados)\n3.3V / 5V     \u2500\u2500\u2500 220\u03a9 \u2500\u2500\u25ba DIN-5 pino 4 (fonte)\nGND           \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba DIN-5 pino 2\n</code></pre> <p>N\u00edvel de tens\u00e3o</p> <p>O MIDI OUT n\u00e3o requer optoacoplador. Os dois resistores de 220\u03a9 limitam a corrente para o LED interno do optoacoplador no dispositivo receptor.</p>"},{"location":"transportes/uart-din5/#midi-in-sintetizador-esp32","title":"MIDI IN (Sintetizador \u2192 ESP32)","text":"<p>Isola\u00e7\u00e3o obrigat\u00f3ria</p> <p>O MIDI IN deve usar um optoacoplador para isolar eletricamente o ESP32 do instrumento. Conectar diretamente pode danificar o ESP32 por diferen\u00e7a de potencial de terra.</p> <pre><code>DIN-5 pino 5 \u2500\u2500\u2500 220\u03a9 \u2500\u2500\u2500 Optoacoplador (LED)\nDIN-5 pino 4 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Optoacoplador (anodo)\nDIN-5 pino 2 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 GND\n\nOptoacoplador (fototransistor):\n  Coletor \u2500\u2500\u2500 3.3V\n  Emissor \u2500\u2500\u2500 1k\u03a9 \u2500\u2500\u2500 ESP32 GPIO RX\n</code></pre> <p>Optoacopladores recomendados:</p> Componente Notas PC-900V Recomendado pela MMA para MIDI 6N138 Mais comum, dispon\u00edvel no Brasil TLP2361 R\u00e1pido, 5V, \u00f3tima escolha H11L1 Alternativa econ\u00f4mica"},{"location":"transportes/uart-din5/#esquema-completo","title":"Esquema Completo","text":"<pre><code>                    MIDI IN\nDIN-5 pino 5 \u2500\u252c\u2500 220\u03a9 \u2500\u25ba LED (+) do 6N138\nDIN-5 pino 4 \u2500\u2518           LED (-) do 6N138\nDIN-5 pino 2 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 GND\n\n6N138 sa\u00edda:\n  VCC (pino 8) \u2500\u2500\u2500 3.3V\n  Vout (pino 6) \u2500\u2500\u2500 ESP32 RX (pull-up interno)\n  GND (pino 4) \u2500\u2500\u2500 GND\n\n                    MIDI OUT\nESP32 TX \u2500\u2500\u2500 220\u03a9 \u2500\u2500\u2500 DIN-5 pino 5\n3.3V     \u2500\u2500\u2500 220\u03a9 \u2500\u2500\u2500 DIN-5 pino 4\nGND      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 DIN-5 pino 2\n</code></pre>"},{"location":"transportes/uart-din5/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/UARTConnection.h\"\n\nUARTConnection uartMIDI;\n\nvoid setup() {\n    Serial.begin(115200);\n\n    // Serial1: RX = GPIO 16, TX = GPIO 17\n    uartMIDI.begin(Serial1, /*RX=*/16, /*TX=*/17);\n\n    midiHandler.addTransport(&amp;uartMIDI);\n    midiHandler.begin();\n\n    Serial.println(\"UART MIDI pronto (31250 baud)\");\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"[DIN-5] %s %s ch=%d vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.channel,\n            ev.velocity);\n    }\n}\n</code></pre>"},{"location":"transportes/uart-din5/#multiplos-uarts-esp32-p4","title":"M\u00faltiplos UARTs (ESP32-P4)","text":"<p>O ESP32-P4 tem 5 UARTs hardware, permitindo m\u00faltiplas portas DIN-5 simult\u00e2neas:</p> <pre><code>#include \"src/UARTConnection.h\"\n\nUARTConnection uart1;  // MIDI IN/OUT porta 1\nUARTConnection uart2;  // MIDI IN/OUT porta 2\n\nvoid setup() {\n    uart1.begin(Serial1, /*RX=*/16, /*TX=*/17);\n    uart2.begin(Serial2, /*RX=*/18, /*TX=*/19);\n\n    midiHandler.addTransport(&amp;uart1);\n    midiHandler.addTransport(&amp;uart2);\n    midiHandler.begin();\n}\n</code></pre>"},{"location":"transportes/uart-din5/#mensagens-midi-suportadas","title":"Mensagens MIDI Suportadas","text":"Mensagem Suporte NoteOn / NoteOff \u2705 Control Change (CC) \u2705 Program Change \u2705 Pitch Bend \u2705 Channel Pressure \u2705 MIDI Clock / Start / Stop \u2705 (real-time messages) Running Status \u2705 (processado automaticamente) SysEx \u274c (ignorado)"},{"location":"transportes/uart-din5/#pinos-disponiveis-por-chip","title":"Pinos Dispon\u00edveis por Chip","text":"Chip UARTs hardware Pinos sugeridos (RX/TX) ESP32 cl\u00e1ssico 3 UART1: 16/17, UART2: 4/2 ESP32-S3 3 UART1: 18/17, UART2: 19/20 ESP32-S2 2 UART1: 18/17 ESP32-P4 5 UART1: 16/17, UART2: 18/19, ... ESP32-C3 2 UART1: 4/5 <p>Evitar GPIO 0</p> <p>N\u00e3o use GPIO 0 para UART MIDI \u2014 ele \u00e9 o bot\u00e3o de boot e pode causar comportamento inesperado.</p>"},{"location":"transportes/uart-din5/#exemplos","title":"Exemplos","text":"Exemplo Descri\u00e7\u00e3o <code>UART-MIDI-Basic</code> DIN-5 entrada \u2192 Serial Monitor <code>P4-Dual-UART-MIDI</code> Dois UARTs no ESP32-P4"},{"location":"transportes/uart-din5/#bridge-din-5-wifi","title":"Bridge DIN-5 \u2194 WiFi","text":"<p>Um caso de uso cl\u00e1ssico: conectar um sintetizador vintage ao macOS via WiFi:</p> <pre><code>Sintetizador DIN-5 \u2192 ESP32 UART \u2192 MIDIHandler \u2192 RTP-MIDI \u2192 macOS Logic Pro\n</code></pre> <pre><code>#include &lt;WiFi.h&gt;\n#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/UARTConnection.h\"\n#include \"src/RTPMIDIConnection.h\"\n\nUARTConnection uartMIDI;\nRTPMIDIConnection rtpMIDI;\n\nvoid setup() {\n    WiFi.begin(\"ssid\", \"password\");\n    while (WiFi.status() != WL_CONNECTED) delay(500);\n\n    uartMIDI.begin(Serial1, 16, 17);\n    rtpMIDI.begin(\"Synth Bridge\");\n\n    midiHandler.addTransport(&amp;uartMIDI);\n    midiHandler.addTransport(&amp;rtpMIDI);\n    midiHandler.begin();\n    // Pronto! DIN-5 \u2194 WiFi bridge autom\u00e1tico\n}\n</code></pre>"},{"location":"transportes/uart-din5/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>RTP-MIDI \u2192 \u2014 combinar UART com WiFi Apple MIDI</li> <li>ESP-NOW \u2192 \u2014 bridge DIN-5 \u2194 ESP-NOW mesh</li> <li>Exemplos UART \u2192 \u2014 sketch completo comentado</li> </ul>"},{"location":"transportes/usb-device/","title":"\ud83d\udcbb USB Device","text":"<p>O ESP32 se apresenta como uma interface USB MIDI class-compliant ao computador host. macOS, Windows e Linux reconhecem instantaneamente \u2014 sem driver, sem configura\u00e7\u00e3o.</p>"},{"location":"transportes/usb-device/#diferenca-usb-host-vs-usb-device","title":"Diferen\u00e7a: USB Host vs. USB Device","text":"Aspecto USB Host USB Device Papel do ESP32 Mestre \u2014 controla o barramento Escravo \u2014 obedece ao computador O que conecta Teclado, pad, controlador Computador (DAW) Aparece onde \u2014 Porta MIDI no DAW Arduino IDE <code>USB Mode \u2192 \"USB Host\"</code> <code>USB Mode \u2192 \"USB-OTG (TinyUSB)\"</code> Coexist\u00eancia \u274c N\u00e3o pode com USB Device \u274c N\u00e3o pode com USB Host <p>Pino OTG compartilhado</p> <p>USB Host e USB Device usam o mesmo pino f\u00edsico OTG. Voc\u00ea deve escolher um em tempo de compila\u00e7\u00e3o \u2014 n\u00e3o \u00e9 poss\u00edvel usar os dois no mesmo sketch.</p>"},{"location":"transportes/usb-device/#hardware-necessario","title":"Hardware Necess\u00e1rio","text":"Requisito Detalhe Chip ESP32-S3, ESP32-S2, ou ESP32-P4 Conex\u00e3o Cabo USB normal do computador para o ESP32 Biblioteca TinyUSB (j\u00e1 inclu\u00edda no arduino-esp32 \u2265 3.0.0)"},{"location":"transportes/usb-device/#configuracao-no-arduino-ide","title":"Configura\u00e7\u00e3o no Arduino IDE","text":"<pre><code>Tools \u2192 USB Mode \u2192 \"USB-OTG (TinyUSB)\"\n</code></pre>"},{"location":"transportes/usb-device/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/USBDeviceConnection.h\"\n// Tools &gt; USB Mode \u2192 \"USB-OTG (TinyUSB)\"\n\nUSBDeviceConnection usbMIDI(\"ESP32 MIDI Hub\");  // Nome da porta no DAW\n\nvoid setup() {\n    Serial.begin(115200);\n\n    // 1. Registrar ANTES de begin()\n    midiHandler.addTransport(&amp;usbMIDI);\n    usbMIDI.begin();\n\n    // 2. Iniciar o handler (BLE pode ser iniciado junto)\n    midiHandler.begin();\n\n    Serial.println(\"USB Device MIDI aguardando conex\u00e3o...\");\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        // MIDI recebido do DAW via USB Device\n        Serial.printf(\"[USB-DEV] %s %s vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.velocity);\n\n        // Re-envia para BLE (bridge autom\u00e1tico)\n    }\n}\n</code></pre>"},{"location":"transportes/usb-device/#uso-como-bridge-bidirecional","title":"Uso como Bridge Bidirecional","text":"<p>O caso de uso mais poderoso: ESP32 conecta ao DAW via USB, e ao mesmo tempo recebe de iOS via BLE \u2014 bridge autom\u00e1tico.</p> <pre><code>flowchart LR\n    subgraph DAW[\"\ud83d\udcbb DAW (Logic, Ableton...)\"]\n        DTRACK[\"Faixa MIDI\"]\n    end\n\n    subgraph ESP32[\"ESP32-S3\"]\n        USBD[\"USB Device\\n(porta MIDI no DAW)\"]\n        BLEC[\"BLE MIDI\\n(perif\u00e9rico iOS)\"]\n        HANDLER[\"MIDIHandler\"]\n    end\n\n    subgraph IOS[\"\ud83d\udcf1 iPhone\"]\n        APP[\"GarageBand / AUM\"]\n    end\n\n    DAW &lt;--&gt;|\"USB MIDI\"| USBD\n    IOS &lt;--&gt;|\"Bluetooth LE\"| BLEC\n    USBD &lt;--&gt; HANDLER\n    BLEC &lt;--&gt; HANDLER\n\n    Note1[\"Qualquer MIDI do DAW\\nchega no iOS e vice-versa\"]\n\n    style ESP32 fill:#3F51B5,color:#fff,stroke:#283593\n    style DAW fill:#1B5E20,color:#fff,stroke:#2E7D32\n    style IOS fill:#BF360C,color:#fff,stroke:#E64A19</code></pre> <pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/USBDeviceConnection.h\"\n// Tools &gt; USB Mode \u2192 \"USB-OTG (TinyUSB)\"\n\nUSBDeviceConnection usbMIDI(\"BLE-USB Bridge\");\n\nvoid setup() {\n    midiHandler.addTransport(&amp;usbMIDI);\n    usbMIDI.begin();\n\n    MIDIHandlerConfig cfg;\n    cfg.bleName = \"Bridge MIDI\";\n    midiHandler.begin(cfg);\n\n    // Pronto! Qualquer MIDI de BLE vai para USB e vice-versa\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        // midiHandler.sendNoteOn() enviaria para AMBOS\n        // Mas a re-transmiss\u00e3o autom\u00e1tica j\u00e1 cobre isso\n    }\n}\n</code></pre>"},{"location":"transportes/usb-device/#nome-da-porta-no-daw","title":"Nome da Porta no DAW","text":"<p>O nome passado para <code>USBDeviceConnection</code> aparece na lista de portas MIDI do DAW:</p> <pre><code>USBDeviceConnection usbMIDI(\"ESP32 MIDI Hub\");  // macOS: \"ESP32 MIDI Hub\"\nUSBDeviceConnection usbMIDI(\"Meu Controlador\"); // Windows: \"Meu Controlador\"\n</code></pre> <p>Renomeando no macOS</p> <p>Em Audio MIDI Setup \u2192 MIDI Studio, voc\u00ea pode renomear a porta de forma permanente clicando duas vezes no nome do dispositivo.</p>"},{"location":"transportes/usb-device/#compatibilidade-com-daws","title":"Compatibilidade com DAWs","text":"DAW Sistema Status Logic Pro macOS \u2705 Plug &amp; Play GarageBand macOS / iOS \u2705 Plug &amp; Play Ableton Live macOS / Windows \u2705 Plug &amp; Play Bitwig Studio macOS / Windows / Linux \u2705 Plug &amp; Play FL Studio Windows / macOS \u2705 Plug &amp; Play Reaper macOS / Windows / Linux \u2705 Plug &amp; Play Pro Tools macOS / Windows \u2705 Com driver CoreMIDI Cubase Windows / macOS \u2705 Plug &amp; Play"},{"location":"transportes/usb-device/#exemplos","title":"Exemplos","text":"Exemplo Descri\u00e7\u00e3o <code>T-Display-S3-USB-Device</code> Bridge BLE + USB Device com display"},{"location":"transportes/usb-device/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>BLE MIDI \u2192 \u2014 usar BLE simultaneamente com USB Device</li> <li>RTP-MIDI \u2192 \u2014 alternativa WiFi (n\u00e3o usa pino OTG)</li> <li>UART / DIN-5 \u2192 \u2014 conectar sintetizadores vintage</li> </ul>"},{"location":"transportes/usb-host/","title":"\ud83d\udd0c USB Host (OTG)","text":"<p>Conecta qualquer dispositivo USB MIDI class-compliant \u2014 teclados, pads, interfaces, controladores \u2014 diretamente ao ESP32 via USB-OTG. Sem hub, sem driver, sem configura\u00e7\u00e3o no computador.</p>"},{"location":"transportes/usb-host/#hardware-necessario","title":"Hardware Necess\u00e1rio","text":"Requisito Detalhe Chip ESP32-S3, ESP32-S2, ou ESP32-P4 Pinos D+ / D- do conector USB-OTG Cabo USB-OTG (host) \u2014 ponta micro-OTG ou USB-A f\u00eamea Placa recomendada LilyGO T-Display-S3 (tem conector OTG nativo) <p>ESP32 Classic N\u00c3O suporta USB Host</p> <p>Apenas S2, S3 e P4 t\u00eam hardware USB-OTG. O ESP32 cl\u00e1ssico (original) n\u00e3o suporta este transporte.</p>"},{"location":"transportes/usb-host/#velocidade-usb","title":"Velocidade USB","text":"Chip Velocidade Largura de Banda ESP32-S2 Full-Speed 12 Mbps ESP32-S3 Full-Speed 12 Mbps ESP32-P4 High-Speed 480 Mbps (hub m\u00faltiplos dispositivos) <p>Para MIDI (31250 baud), Full-Speed \u00e9 mais que suficiente. O ESP32-P4 com High-Speed permite conectar hubs USB com m\u00faltiplos dispositivos simult\u00e2neos.</p>"},{"location":"transportes/usb-host/#configuracao-no-arduino-ide","title":"Configura\u00e7\u00e3o no Arduino IDE","text":"<pre><code>Tools \u2192 USB Mode \u2192 \"USB Host\"\n</code></pre> <p>Note</p> <p>Esta op\u00e7\u00e3o s\u00f3 aparece quando voc\u00ea seleciona uma placa ESP32-S3, S2 ou P4 no Board Manager.</p>"},{"location":"transportes/usb-host/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n// Tools &gt; USB Mode \u2192 \"USB Host\"\n\nvoid setup() {\n    Serial.begin(115200);\n    midiHandler.begin();  // USB Host iniciado automaticamente\n}\n\nvoid loop() {\n    midiHandler.task();\n\n    for (const auto&amp; ev : midiHandler.getQueue()) {\n        Serial.printf(\"[USB] %s %s ch=%d vel=%d\\n\",\n            ev.status.c_str(),\n            ev.noteOctave.c_str(),\n            ev.channel,\n            ev.velocity);\n    }\n}\n</code></pre> <p>Nenhuma configura\u00e7\u00e3o adicional \u00e9 necess\u00e1ria \u2014 o transporte USB \u00e9 built-in.</p>"},{"location":"transportes/usb-host/#fluxo-interno-de-dados","title":"Fluxo Interno de Dados","text":"<pre><code>sequenceDiagram\n    participant DEV as \ud83c\udfb9 Teclado USB\n    participant DRIVER as USB Host Driver (Core 0)\n    participant BUF as Ring Buffer (64 slots)\n    participant HANDLER as MIDIHandler (Core 1)\n\n    DEV-&gt;&gt;DRIVER: Pacote USB-MIDI (4 bytes)\n    Note over DRIVER: CIN=0x09 (NoteOn)&lt;br/&gt;0x90 0x3C 0x64\n    DRIVER-&gt;&gt;BUF: Armazena com portMUX (thread-safe)\n\n    loop Cada loop() no Core 1\n        HANDLER-&gt;&gt;BUF: task() \u2014 l\u00ea mensagens\n        BUF-&gt;&gt;HANDLER: [0x09, 0x90, 0x3C, 0x64]\n        HANDLER-&gt;&gt;HANDLER: Parseia \u2192 MIDIEventData\n        Note right of HANDLER: status=\"NoteOn\"&lt;br/&gt;note=60, noteName=\"C\"&lt;br/&gt;noteOctave=\"C4\"&lt;br/&gt;velocity=100\n    end</code></pre>"},{"location":"transportes/usb-host/#formato-do-pacote-usb-midi","title":"Formato do Pacote USB-MIDI","text":"<pre><code>Byte 0: CIN (Cable Index Number)  \u2014 tipo da mensagem\nByte 1: Status MIDI               \u2014 0x90 = NoteOn canal 1\nByte 2: Data 1                    \u2014 nota (0-127)\nByte 3: Data 2                    \u2014 velocidade (0-127)\n</code></pre>"},{"location":"transportes/usb-host/#dispositivos-suportados","title":"Dispositivos Suportados","text":"<p>Qualquer dispositivo USB MIDI 1.0 Class Compliant funciona sem driver:</p> <ul> <li>Teclados MIDI (Arturia, Akai, Native Instruments, Roland, Yamaha...)</li> <li>Pads de percuss\u00e3o (Akai MPC, Roland SPD...)</li> <li>Interfaces de \u00e1udio com porta MIDI (Focusrite, PreSonus...)</li> <li>Controladores DJ (Numark, Pioneer...)</li> <li>Footswitches e pedaleiras MIDI</li> <li>Instrumentos de sopro digitais (Akai EWI)</li> </ul> <p>Como verificar se \u00e9 class-compliant</p> <p>Se o dispositivo funciona em macOS ou Linux sem instalar driver, \u00e9 class-compliant e vai funcionar com ESP32_Host_MIDI.</p>"},{"location":"transportes/usb-host/#limitacoes","title":"Limita\u00e7\u00f5es","text":"<ul> <li>Um dispositivo por vez (sem hub, exceto no P4)</li> <li>Apenas USB MIDI 1.0 (n\u00e3o suporta USB Audio ou HID)</li> <li>N\u00e3o pode coexistir com USB Device \u2014 ambos usam o mesmo pino OTG</li> </ul>"},{"location":"transportes/usb-host/#exemplos-com-usb-host","title":"Exemplos com USB Host","text":"Exemplo O que mostra <code>T-Display-S3</code> Notas ativas + log de eventos no display <code>T-Display-S3-Queue</code> Fila de eventos completa com debug <code>T-Display-S3-Piano</code> Piano roll de 25 teclas com rolagem <code>T-Display-S3-Gingoduino</code> Detec\u00e7\u00e3o de acordes em tempo real"},{"location":"transportes/usb-host/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>BLE MIDI \u2192 \u2014 adicionar Bluetooth sem remover o USB</li> <li>USB Device \u2192 \u2014 ESP32 como interface USB para DAW (mutualmente exclusivo com USB Host)</li> <li>Primeiros Passos \u2192 \u2014 sketch completo USB + BLE</li> </ul>"},{"location":"transportes/visao-geral/","title":"\ud83d\udce1 Transportes \u2014 Vis\u00e3o Geral","text":"<p>A biblioteca suporta 9 transportes MIDI simult\u00e2neos. Cada um implementa a mesma interface abstrata <code>MIDITransport</code>, garantindo que o <code>MIDIHandler</code> os trate de forma uniforme.</p>"},{"location":"transportes/visao-geral/#comparacao-de-transportes","title":"Compara\u00e7\u00e3o de Transportes","text":"Transporte Protocolo F\u00edsica Lat\u00eancia Chips Biblioteca extra \ud83d\udd0c USB Host USB MIDI 1.0 Cabo USB-OTG &lt; 1 ms S3 / S2 / P4 Nenhuma \ud83d\udcf1 BLE MIDI BLE MIDI 1.0 Bluetooth LE 5.0 3\u201315 ms S3 / Classic / C3 / C6 Nenhuma \ud83d\udcbb USB Device USB MIDI 1.0 Cabo USB-OTG &lt; 1 ms S3 / S2 / P4 Nenhuma (TinyUSB) \ud83d\udce1 ESP-NOW ESP-NOW R\u00e1dio 2,4 GHz 1\u20135 ms Qualquer ESP32 Nenhuma \ud83c\udf10 RTP-MIDI AppleMIDI / RFC 6295 WiFi UDP 5\u201320 ms Qualquer com WiFi AppleMIDI-Library \ud83d\udd17 Ethernet AppleMIDI / RFC 6295 Cabeado Ethernet 2\u201310 ms W5500 SPI ou P4 AppleMIDI-Library + Ethernet \ud83c\udfa8 OSC Open Sound Control WiFi UDP 5\u201315 ms Qualquer com WiFi CNMAT/OSC \ud83c\udfb9 UART / DIN-5 Serial MIDI 1.0 (31250 baud) Conector DIN-5 &lt; 1 ms Qualquer ESP32 Nenhuma \ud83d\ude80 MIDI 2.0 UMP over UDP WiFi UDP 5\u201320 ms Qualquer com WiFi Nenhuma"},{"location":"transportes/visao-geral/#transportes-built-in-vs-externos","title":"Transportes Built-in vs. Externos","text":"<pre><code>graph LR\n    subgraph BUILTIN[\"\u2705 Built-in \u2014 registrados automaticamente\"]\n        USB[\"\ud83d\udd0c USB Host\\n(ESP32-S3/S2/P4)\"]\n        BLE[\"\ud83d\udcf1 BLE MIDI\\n(ESP32 com Bluetooth)\"]\n        ESPNOW[\"\ud83d\udce1 ESP-NOW\\n(qualquer ESP32)\"]\n    end\n\n    subgraph EXTERNAL[\"\ud83d\udce6 Externos \u2014 incluir manualmente\"]\n        UART[\"\ud83c\udfb9 UARTConnection\"]\n        RTP[\"\ud83c\udf10 RTPMIDIConnection\"]\n        ETH[\"\ud83d\udd17 EthernetMIDIConnection\"]\n        OSC[\"\ud83c\udfa8 OSCConnection\"]\n        MIDI2[\"\ud83d\ude80 MIDI2UDPConnection\"]\n        USBDEV[\"\ud83d\udcbb USBDeviceConnection\"]\n    end\n\n    BUILTIN --&gt; HANDLER[\"MIDIHandler\\nmidiHandler.begin()\"]\n    EXTERNAL --&gt; ADD[\"midiHandler.addTransport()\"]\n    ADD --&gt; HANDLER\n\n    style BUILTIN fill:#1B5E20,color:#fff,stroke:#2E7D32\n    style EXTERNAL fill:#1A237E,color:#fff,stroke:#283593\n    style HANDLER fill:#3F51B5,color:#fff,stroke:#283593</code></pre>"},{"location":"transportes/visao-geral/#transportes-built-in","title":"Transportes Built-in","text":"<p>Registrados automaticamente quando o chip suporta:</p> <pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n\nvoid setup() {\n    midiHandler.begin();  // USB + BLE + ESP-NOW iniciados automaticamente\n}\n</code></pre>"},{"location":"transportes/visao-geral/#transportes-externos","title":"Transportes Externos","text":"<p>Devem ser inclu\u00eddos e registrados manualmente:</p> <pre><code>#include &lt;ESP32_Host_MIDI.h&gt;\n#include \"src/UARTConnection.h\"     // DIN-5 MIDI serial\n#include \"src/RTPMIDIConnection.h\"  // Apple MIDI via WiFi\n#include \"src/OSCConnection.h\"      // OSC via WiFi\n\nUARTConnection uartMIDI;\nRTPMIDIConnection rtpMIDI;\nOSCConnection oscMIDI;\n\nvoid setup() {\n    // 1. Inicializar transportes externos\n    uartMIDI.begin(Serial1, 16, 17);\n    rtpMIDI.begin(\"Meu ESP32\");\n    oscMIDI.begin(8000, IPAddress(192,168,1,100), 9000);\n\n    // 2. Registrar no handler\n    midiHandler.addTransport(&amp;uartMIDI);\n    midiHandler.addTransport(&amp;rtpMIDI);\n    midiHandler.addTransport(&amp;oscMIDI);\n\n    // 3. Iniciar o handler\n    midiHandler.begin();\n}\n</code></pre> <p>Limite de transportes</p> <p>O <code>MIDIHandler</code> suporta at\u00e9 4 transportes externos via <code>addTransport()</code>. Os transportes built-in (USB, BLE, ESP-NOW) n\u00e3o contam neste limite.</p>"},{"location":"transportes/visao-geral/#compatibilidade-por-chip","title":"Compatibilidade por Chip","text":"<pre><code>graph TD\n    subgraph ESP32S3[\"ESP32-S3 \u2b50 Mais vers\u00e1til\"]\n        S3_USB[\"\u2705 USB Host\"]\n        S3_BLE[\"\u2705 BLE MIDI\"]\n        S3_DEV[\"\u2705 USB Device\"]\n        S3_WIFI[\"\u2705 RTP-MIDI / OSC\"]\n        S3_NOW[\"\u2705 ESP-NOW\"]\n        S3_UART[\"\u2705 UART / DIN-5\"]\n    end\n\n    subgraph ESP32S2[\"ESP32-S2\"]\n        S2_USB[\"\u2705 USB Host\"]\n        S2_DEV[\"\u2705 USB Device\"]\n        S2_WIFI[\"\u2705 RTP-MIDI / OSC\"]\n        S2_UART[\"\u2705 UART / DIN-5\"]\n        S2_BLE[\"\u274c BLE (sem Bluetooth)\"]\n    end\n\n    subgraph ESP32P4[\"ESP32-P4 \ud83d\udd25 Mais r\u00e1pido\"]\n        P4_USB[\"\u2705 USB Host HS (480 Mbps)\"]\n        P4_DEV[\"\u2705 USB Device\"]\n        P4_ETH[\"\u2705 Ethernet MAC nativo\"]\n        P4_UART[\"\u2705 UART \u00d75\"]\n        P4_BLE[\"\u274c BLE\"]\n        P4_WIFI[\"\u274c WiFi (sem r\u00e1dio)\"]\n    end\n\n    subgraph ESP32C[\"ESP32-C3 / C6 / H2\"]\n        C_BLE[\"\u2705 BLE MIDI\"]\n        C_UART[\"\u2705 UART / DIN-5\"]\n        C_WIFI[\"\u2705 RTP-MIDI / OSC\"]\n        C_NOW[\"\u2705 ESP-NOW\"]\n        C_USB[\"\u274c USB Host\"]\n    end\n\n    style ESP32S3 fill:#1B5E20,color:#fff,stroke:#2E7D32\n    style ESP32S2 fill:#1565C0,color:#fff,stroke:#0D47A1\n    style ESP32P4 fill:#4A148C,color:#fff,stroke:#6A1B9A\n    style ESP32C fill:#37474F,color:#fff,stroke:#546E7A</code></pre>"},{"location":"transportes/visao-geral/#interface-miditransport","title":"Interface MIDITransport","text":"<p>Todos os transportes implementam esta interface:</p> <pre><code>class MIDITransport {\npublic:\n    virtual void task() = 0;                              // Chamado a cada loop()\n    virtual bool isConnected() const = 0;                 // Status da conex\u00e3o\n\n    // Opcional \u2014 envio de MIDI (fallback: return false)\n    virtual bool sendMidiMessage(const uint8_t* data, size_t length);\n\n    // Registro de callbacks (usado internamente pelo MIDIHandler)\n    void setMidiCallback(MidiDataCallback cb, void* ctx);\n    void setConnectionCallbacks(ConnectionCallback onConn,\n                                ConnectionCallback onDisconn, void* ctx);\n\nprotected:\n    // Chamados pelas implementa\u00e7\u00f5es para injetar dados\n    void dispatchMidiData(const uint8_t* data, size_t len);\n    void dispatchConnected();\n    void dispatchDisconnected();\n};\n</code></pre>"},{"location":"transportes/visao-geral/#criar-um-transporte-customizado","title":"Criar um Transporte Customizado","text":"<pre><code>class MyTransport : public MIDITransport {\npublic:\n    void begin() {\n        // Inicializar hardware/conex\u00e3o\n    }\n\n    void task() override {\n        // Verificar se h\u00e1 dados dispon\u00edveis\n        if (hasData()) {\n            uint8_t buf[3];\n            readMidi(buf);\n            dispatchMidiData(buf, 3);  // Injeta no MIDIHandler\n        }\n    }\n\n    bool isConnected() const override {\n        return connected;\n    }\n\n    bool sendMidiMessage(const uint8_t* data, size_t len) override {\n        // Enviar via seu protocolo\n        return writeMidi(data, len);\n    }\n};\n\nMyTransport myTransport;\n\nvoid setup() {\n    myTransport.begin();\n    midiHandler.addTransport(&amp;myTransport);\n    midiHandler.begin();\n}\n</code></pre>"},{"location":"transportes/visao-geral/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Explore cada transporte em detalhe:</p> <ul> <li>\ud83d\udd0c USB Host \u2014 teclados e pads USB class-compliant</li> <li>\ud83d\udcf1 BLE MIDI \u2014 iOS, macOS e Android</li> <li>\ud83d\udcbb USB Device \u2014 ESP32 como interface USB para DAW</li> <li>\ud83c\udfb9 UART / DIN-5 \u2014 sintetizadores vintage</li> <li>\ud83c\udf10 RTP-MIDI \u2014 Apple MIDI via WiFi</li> <li>\ud83d\udd17 Ethernet \u2014 Ethernet cabeada para est\u00fadio</li> <li>\ud83d\udce1 ESP-NOW \u2014 mesh sem fio entre ESP32</li> <li>\ud83c\udfa8 OSC \u2014 Max/MSP, Pure Data, SuperCollider</li> <li>\ud83d\ude80 MIDI 2.0 \u2014 alta resolu\u00e7\u00e3o com UMP</li> </ul>"}]}